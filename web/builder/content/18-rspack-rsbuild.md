# Rspack 与 Rsbuild

## 概述

Rspack / Rsbuild 属于“新一代工具链”里非常务实的一支：

- **Rspack**：偏“构建引擎/打包器（bundler）”，目标之一是兼容 webpack 生态，同时显著提升性能
- **Rsbuild**：偏“应用级构建工具”，在 Rspack 之上提供开箱即用的工程体验与默认最佳实践

你可以用一句话建立直觉：

> **Rspack 更像更快的 webpack 引擎，Rsbuild 更像更省心的应用平台**。

---

## 一、Rspack：为什么它会出现

### 1.1 现实问题：webpack 生态太大、迁移成本太高

在企业里，webpack 的“强”来自生态与历史积累。

但大型项目常遇到：

- 冷启动慢
- 增量构建慢
- CI 构建耗时高

因此行业出现一类需求：

- **不想重写构建体系**（迁移成本太高）
- **又想显著提升性能**

Rspack 的策略就是：尽量兼容 webpack 的使用方式（配置与生态），同时用 Rust 提升性能上限。

---

## 二、Rspack 的核心设计目标

### 2.1 性能：Rust 实现与更强并行

- Rust 的实现更容易做高性能与并行化
- 在大型依赖图与复杂构建场景下，性能收益更明显

### 2.2 兼容：降低迁移门槛

- 配置形态尽量贴近 webpack
- 生态兼容是关键卖点之一（但现实上会存在差异与边界）

> **关键点**
>
> “兼容”不是 100% 等价；你应当把它理解为“迁移成本显著降低”，而不是“零成本替换”。

---

## 三、Rsbuild：为什么需要它（应用级工具的价值）

即使你有了一个高性能 bundler，引入到团队里仍然会遇到：

- 配置组织（多环境/多框架）
- 常用最佳实践默认值（缓存、拆包、polyfill 策略）
- 插件组合与升级

Rsbuild 的价值在于：

- 把一套“可用的工程体验”封装好
- 让团队减少“重复造配置轮子”的成本

---

## 四、适用场景与不擅长什么

### 4.1 更适合

- 大型应用、企业级项目
- 已有 webpack 生态（loader/plugin）且希望提速
- 对产物控制与稳定性要求较高

### 4.2 需要谨慎

- 插件/loader 兼容边界（某些社区插件可能存在差异）
- 团队对新工具的掌控与故障排查成本

> **建议**
>
> 如果你是存量 webpack 项目，优先考虑“渐进迁移 + 性能收益评估”，而不是一次性替换。

---

## 参考资料

- [Rspack 官方文档](https://rspack.dev/)
- [Rsbuild 官方文档](https://rsbuild.dev/)
- [webpack 官方文档](https://webpack.js.org/)
