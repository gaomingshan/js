# 前端开发的演进历程

## 概述

早期的前端开发更像“页面脚本编写”：把若干个 `<script>` 引入到 HTML 中，靠约定来维持依赖顺序。

当业务复杂度、代码规模、依赖数量增长后，前端逐渐形成一条稳定的工程流水线：**源码（Authoring）→ 构建（Build）→ 产物（Delivery）**。

理解构建工具出现的根本原因，不在于“工具更强”，而在于**我们写的代码**与**浏览器更希望拿到的代码**之间存在天然鸿沟：

- 代码组织从“全局脚本”升级为“模块依赖图”
- 语法从 ES5 升级到 TypeScript/JSX/现代 ESM
- 性能目标从“能运行”升级为“快、可缓存、可拆分、可观测”

---

## 一、没有构建工具的时代：Script 标签与全局命名空间

### 1.1 开发方式（典型形态）

```html
<script src="./jquery.js"></script>
<script src="./utils.js"></script>
<script src="./app.js"></script>
```

特点：

- 每个文件共享同一个全局作用域（`window`）
- 依赖顺序由人手工维护
- 资源的版本与缓存策略也由人手工维护

> **关键点**
>
> 这套方式的“依赖关系”存在于人的脑子里，而不是机器可分析的结构里。

### 1.2 随规模增长出现的痛点

- **命名冲突与全局污染**：`utils.format`、`app.format` 谁覆盖谁？
- **顺序脆弱**：加载顺序一错就是运行时错误
- **协作困难**：多人改同一个全局空间，容易互相影响
- **缓存不可控**：文件名不变时，浏览器缓存无法精确失效

---

## 二、Node.js 与 npm：依赖规模爆炸

### 2.1 npm 带来的变化

依赖从“几段脚本”变成“依赖树”：

```text
app
└─ react
   ├─ scheduler
   └─ loose-envify
      └─ js-tokens
```

### 2.2 为什么不能直接把 `node_modules` 交给浏览器

通常不行，原因包括：

- **模块规范不匹配**：许多包历史上以 CommonJS（`require`）输出
- **导入语法不匹配**：浏览器原生 ESM 要求明确路径，而 npm 包常用“裸导入”
  - `import React from 'react'`（裸导入）
  - 浏览器更需要 `import React from '/node_modules/react/index.js'`（显式路径）
- **请求数量与瀑布问题**：模块数太多会导致大量请求与依赖层级瀑布
- **语法与目标环境差异**：包可能包含未转译的新语法、不同环境分支

---

## 三、SPA 与框架化：开发体验成为刚需

### 3.1 复杂度的变化

从“页面脚本”变为“应用程序”：

- 路由、组件、状态管理、数据层
- SSR/CSR 混合渲染
- 多环境配置、灰度发布、监控与告警

### 3.2 研发过程的新诉求

- **更快的反馈**：保存即生效（HMR）、增量编译
- **更好的可调试性**：Source Map
- **更强的质量保障**：类型检查、Lint、测试、CI

> **直觉理解**
>
> 现代前端不是“写网页”，而是在开发一个运行在浏览器里的应用程序。应用程序天然需要“编译/构建”。

---

## 四、现代工程的“源码-产物”鸿沟

### 4.1 我们写的（Authoring）

- TypeScript / JSX
- 现代 ESM + 动态 `import()`
- PostCSS / CSS Modules / Sass
- 资源导入（图片、字体、SVG、JSON）

### 4.2 浏览器更希望拿到的（Delivery）

- **更少的文件**（尤其是首屏关键资源）
- **可长期缓存**（带内容哈希：内容变才变名）
- **按需加载**（拆包 / code splitting）
- **面向目标浏览器**（语法降级与必要 polyfill）

---

## 五、从“手工拼接”到“构建流水线”

一个典型的构建过程可以抽象为：

```text
源码(模块图)
  ├─ 依赖解析 / 模块解析
  ├─ 转译(TS/JSX/新语法)
  ├─ 打包(拆包/合并/运行时)
  ├─ 优化(Tree Shaking/压缩/去重)
  └─ 输出(哈希/清单/HTML 注入)
产物(可部署资源)
```

> **深入一点**
>
> 构建工具的“本质角色”接近编译器：它不仅把代码变成另一种代码，还要把一个“模块图”变成“可部署的资源集合”。

---

## 参考资料

- [MDN - JavaScript modules](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Modules)
- [HTTP 缓存（概览）- MDN](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Caching)
- [Vite - Why Vite](https://vite.dev/guide/why.html)
