/**
 * 装饰器提案
 * 包含多种题型：单选、多选、代码输出、判断、代码补全
 */
window.quizData_Deep2704DecoratorsProposal = {
  "config": {
    "title": "装饰器提案",
    "icon": "✨",
    "description": "理解Stage 3装饰器提案",
    "primaryColor": "#ec4899",
    "bgGradient": "linear-gradient(135deg, #ec4899 0%, #db2777 100%)"
  },
  "questions": [
    {"type": "single-choice", "difficulty": "easy", "tags": ["装饰器"], "question": "装饰器提案当前是什么阶段？", "options": ["Stage 3", "Stage 2", "Stage 1", "Stage 4"], "correctAnswer": "A", "explanation": {"title": "装饰器阶段", "code": "// Decorators：Stage 3（2022）\n// 与TypeScript装饰器不同\n\n// 类装饰器\n@logged\nclass MyClass {}\n\n// 方法装饰器\nclass User {\n  @readonly\n  name = 'Alice';\n  \n  @memoize\n  compute() {}\n}"}},
    {"type": "multiple-choice", "difficulty": "hard", "tags": ["类型"], "question": "装饰器可以装饰什么？", "options": ["类", "方法", "属性", "函数", "访问器", "参数"], "correctAnswer": ["A", "B", "C", "E"], "explanation": {"title": "装饰器类型", "code": "// 1. 类装饰器\n@register\nclass Service {}\n\n// 2. 方法装饰器\nclass API {\n  @logged\n  fetchData() {}\n}\n\n// 3. 字段装饰器\nclass Model {\n  @validate\n  email = '';\n}\n\n// 4. 访问器装饰器\nclass Person {\n  @readonly\n  get name() { return this._name; }\n}\n\n// ❌ 不支持：\n// - 函数装饰器\n// - 参数装饰器（在新提案中）"}},
    {"type": "true-false", "difficulty": "medium", "tags": ["执行时机"], "question": "装饰器在类定义时执行", "correctAnswer": "A", "explanation": {"title": "执行时机", "code": "// 装饰器在类定义时执行\nconsole.log('Before class');\n\n@logged\nclass MyClass {\n  @memoize\n  method() {}\n}\n\nconsole.log('After class');\n\n// 输出：\n// Before class\n// logged decorator executed\n// memoize decorator executed\n// After class\n\n// 执行顺序：\n// 1. 成员装饰器（从下到上）\n// 2. 类装饰器"}},
    {"type": "code-completion", "difficulty": "hard", "tags": ["实现"], "question": "实现readonly装饰器，空白处填什么？", "code": "function readonly(value, context) {\n  return function(initialValue) {\n    return {\n      get() { return initialValue; },\n      set() { throw new Error('Readonly'); },\n      ______: true\n    };\n  };\n}", "options": ["configurable", "writable", "enumerable", "readonly"], "correctAnswer": "A", "explanation": {"title": "装饰器实现", "code": "// 字段装饰器\nfunction readonly(value, context) {\n  return function(initialValue) {\n    return {\n      get() { return initialValue; },\n      set() {\n        throw new Error('Cannot modify readonly field');\n      },\n      configurable: false\n    };\n  };\n}\n\n// 使用\nclass User {\n  @readonly\n  id = 123;\n}\n\nconst user = new User();\n// user.id = 456;  // Error\n\n// 方法装饰器\nfunction logged(value, context) {\n  return function(...args) {\n    console.log(`Calling ${context.name}`);\n    return value.apply(this, args);\n  };\n}"}},
    {"type": "code-output", "difficulty": "hard", "tags": ["多装饰器"], "question": "多个装饰器的执行顺序？", "code": "@a\n@b\n@c\nclass MyClass {}\n\n// 执行顺序是？", "options": ["c, b, a", "a, b, c", "b, c, a", "同时执行"], "correctAnswer": "A", "explanation": {"title": "装饰器顺序", "code": "// 多个装饰器：从下到上执行\nfunction a(target) {\n  console.log('a');\n  return target;\n}\n\nfunction b(target) {\n  console.log('b');\n  return target;\n}\n\nfunction c(target) {\n  console.log('c');\n  return target;\n}\n\n@a\n@b\n@c\nclass MyClass {}\n\n// 输出：\n// c\n// b\n// a\n\n// 类比函数组合\n// @a @b @c Class = a(b(c(Class)))"}},
    {"type": "multiple-choice", "difficulty": "hard", "tags": ["应用"], "question": "装饰器的应用场景？", "options": ["日志记录", "性能监控", "权限验证", "数据绑定", "类型检查", "代码压缩"], "correctAnswer": ["A", "B", "C", "D"], "explanation": {"title": "应用场景", "code": "// 1. 日志\nfunction logged(value, context) {\n  return function(...args) {\n    console.log(`${context.name}(${args})`);\n    return value.apply(this, args);\n  };\n}\n\n// 2. 性能\nfunction measure(value, context) {\n  return function(...args) {\n    const start = performance.now();\n    const result = value.apply(this, args);\n    console.log(`${context.name}: ${performance.now() - start}ms`);\n    return result;\n  };\n}\n\n// 3. 权限\nfunction requireAuth(value, context) {\n  return function(...args) {\n    if (!currentUser.isAuthenticated()) {\n      throw new Error('Unauthorized');\n    }\n    return value.apply(this, args);\n  };\n}\n\n// 4. 验证\nfunction validate(schema) {\n  return function(value, context) {\n    return function(initialValue) {\n      if (!schema.validate(initialValue)) {\n        throw new Error('Invalid value');\n      }\n      return initialValue;\n    };\n  };\n}"}},
    {"type": "true-false", "difficulty": "easy", "tags": ["元数据"], "question": "新装饰器提案不支持元数据", "correctAnswer": "B", "explanation": {"title": "装饰器元数据", "code": "// 装饰器支持元数据（通过context）\nfunction myDecorator(value, context) {\n  console.log(context.kind);  // 'class'/'method'/'field'\n  console.log(context.name);  // 成员名称\n  console.log(context.access);  // 访问器\n  console.log(context.private);  // 是否私有\n  console.log(context.static);  // 是否静态\n  \n  // 添加元数据\n  context.addInitializer(function() {\n    console.log('Initializing');\n  });\n}"}},
    {"type": "code-completion", "difficulty": "hard", "tags": ["工厂"], "question": "装饰器工厂，空白处填什么？", "code": "function debounce(ms) {\n  return ______(value, context) {\n    let timeout;\n    return function(...args) {\n      clearTimeout(timeout);\n      timeout = setTimeout(() => value.apply(this, args), ms);\n    };\n  };\n}", "options": ["function", "=>", "async", "class"], "correctAnswer": "A", "explanation": {"title": "装饰器工厂", "code": "// 装饰器工厂：返回装饰器的函数\nfunction debounce(ms) {\n  return function(value, context) {\n    let timeout;\n    return function(...args) {\n      clearTimeout(timeout);\n      timeout = setTimeout(\n        () => value.apply(this, args),\n        ms\n      );\n    };\n  };\n}\n\n// 使用\nclass Search {\n  @debounce(500)\n  onInput(text) {\n    console.log('Searching:', text);\n  }\n}\n\n// 其他工厂示例\nfunction memoize(size = 100) {\n  return function(value, context) {\n    const cache = new Map();\n    return function(...args) {\n      const key = JSON.stringify(args);\n      if (cache.has(key)) return cache.get(key);\n      \n      const result = value.apply(this, args);\n      cache.set(key, result);\n      if (cache.size > size) {\n        const first = cache.keys().next().value;\n        cache.delete(first);\n      }\n      return result;\n    };\n  };\n}"}},
    {"type": "multiple-choice", "difficulty": "hard", "tags": ["vs TypeScript"], "question": "Stage 3装饰器与TypeScript装饰器的区别？", "options": ["参数不同", "执行时机不同", "元数据API不同", "完全相同", "返回值不同", "支持类型不同"], "correctAnswer": ["A", "C", "E"], "explanation": {"title": "对比TS装饰器", "code": "// Stage 3装饰器\nfunction logged(value, context) {\n  // value: 被装饰的值\n  // context: 上下文对象\n  return function replacement(...args) {\n    console.log('called');\n    return value.apply(this, args);\n  };\n}\n\n// TypeScript装饰器（旧）\nfunction logged(target, propertyKey, descriptor) {\n  // target: 类原型\n  // propertyKey: 成员名\n  // descriptor: 属性描述符\n  const original = descriptor.value;\n  descriptor.value = function(...args) {\n    console.log('called');\n    return original.apply(this, args);\n  };\n}\n\n// 主要区别：\n// 1. 参数签名不同\n// 2. 返回值语义不同\n// 3. 元数据访问方式不同"}},
    {"type": "code-output", "difficulty": "hard", "tags": ["最佳实践"], "question": "装饰器最佳实践？", "code": "// 哪个是正确的装饰器写法？\n\n// A:\nfunction deco(value, context) {\n  return function(...args) {\n    return value.apply(this, args);\n  };\n}\n\n// B:\nfunction deco(target) {\n  return class extends target {};\n}", "options": ["A（Stage 3）", "B（TypeScript）", "都对", "都错"], "correctAnswer": "A", "explanation": {"title": "装饰器最佳实践", "code": "// 1. 使用新API（Stage 3）\nfunction decorator(value, context) {\n  // value: 被装饰的值\n  // context: 元数据\n  return function replacement(...args) {\n    // 新行为\n    return value.apply(this, args);\n  };\n}\n\n// 2. 添加初始化器\nfunction init(value, context) {\n  context.addInitializer(function() {\n    console.log('Initialized');\n  });\n}\n\n// 3. 类型安全（TypeScript）\ntype DecoratorFunction = (\n  value: Function,\n  context: ClassMethodDecoratorContext\n) => Function;\n\n// 4. 文档化\n/**\n * 记录方法调用日志\n * @param value - 原方法\n * @param context - 装饰器上下文\n */\nfunction logged(value, context) {\n  // ...\n}\n\n// 5. 错误处理\nfunction safe(value, context) {\n  return function(...args) {\n    try {\n      return value.apply(this, args);\n    } catch (e) {\n      console.error(`Error in ${context.name}:`, e);\n      throw e;\n    }\n  };\n}"}}
  ],
  "navigation": {
    "prev": {"title": "管道操作符", "url": "27-03-pipeline-operator.html"},
    "next": {"title": "Temporal API", "url": "27-05-temporal.html"}
  }
};
