# 垃圾回收算法

## 概述

垃圾回收（Garbage Collection, GC）是 JavaScript 自动内存管理的核心机制。

理解垃圾回收的关键在于：

- **标记清除（Mark-Sweep）**：现代 JS 引擎的主流算法
- **分代回收（Generational GC）**：新生代 vs 老生代
- **增量标记（Incremental Marking）**：减少停顿时间

---

## 一、引用计数（Reference Counting）

### 1.1 基本原理

```js
// 引用计数：记录每个对象被引用的次数
// 当引用计数为 0 时，对象可以被回收

let obj = { x: 1 };    // obj 的引用计数 = 1

let obj2 = obj;        // obj 的引用计数 = 2

obj = null;            // obj 的引用计数 = 1
obj2 = null;           // obj 的引用计数 = 0，可以回收
```

### 1.2 循环引用问题

```js
// ❌ 循环引用导致内存泄漏（在纯引用计数算法中）
function problem() {
  let obj1 = {};
  let obj2 = {};

  obj1.ref = obj2;  // obj1 引用 obj2
  obj2.ref = obj1;  // obj2 引用 obj1

  // 函数结束后，obj1 和 obj2 的引用计数都不为 0
  // 在纯引用计数算法中无法回收
}

// ✅ 现代 JavaScript 引擎使用标记清除，可以处理循环引用
```

---

## 二、标记清除（Mark-Sweep）

### 2.1 基本原理

```js
// 标记清除分两个阶段：

// 1. 标记阶段（Mark）
// - 从根对象开始遍历（全局对象、活动函数栈等）
// - 标记所有可达的对象

// 2. 清除阶段（Sweep）
// - 遍历堆中所有对象
// - 回收未被标记的对象

// 示例：
let obj1 = { x: 1 };     // 可达（被 obj1 引用）
let obj2 = { y: 2 };     // 可达（被 obj2 引用）

obj1 = null;             // obj1 指向的对象变为不可达
// 在下次 GC 时被回收
```

### 2.2 根对象

```js
// GC 的根对象包括：

// 1. 全局对象
window.globalVar = { data: 'global' };  // 可达

// 2. 活动函数的局部变量
function active() {
  let local = { data: 'local' };      // 可达
}

// 3. 活动函数的参数
function fn(param) {                     // param 可达
  // ...
}

// 4. 当前执行上下文的闭包变量
function outer() {
  let closure = { data: 'closure' };
  return function() {
    console.log(closure);            // closure 可达
  };
}
```

### 2.3 优缺点

**优点**：

- 可以处理循环引用
- 实现相对简单

**缺点**：

- GC 期间需要暂停程序（Stop-The-World）
- 会产生内存碎片
- 大堆时标记和清除时间长

---

## 三、标记整理（Mark-Compact）

### 3.1 基本原理

```js
// 标记整理 = 标记清除 + 内存整理

// 阶段：
// 1. 标记：标记所有可达对象
// 2. 整理：将存活对象移动到内存的一端
// 3. 清除：清理边界外的内存

// 优点：解决内存碎片问题
// 缺点：移动对象需要更新所有引用，开销大

// 内存布局示例：
// 标记前：[A][ ][B][C][ ][ ][D]
// 标记后：[A*][ ][B*][C*][ ][ ][D*]
// 整理后：[A][B][C][D][ ][ ][ ]
```

---

## 四、分代回收（Generational GC）

### 4.1 代际假说

**两个假说**：

- **大部分对象很快死亡**：临时变量、函数调用等
- **存活时间长的对象很少死亡**：全局对象、长期缓存等

### 4.2 V8 的分代策略

```js
// V8 将堆分为两代：

// 1. 新生代（New Generation / Young Generation）
// - 存放新创建的对象
// - 空间小（32MB / 16MB）
// - 使用 Scavenge 算法（复制算法）
// - 回收频繁，速度快

// 2. 老生代（Old Generation）
// - 存放存活时间长的对象
// - 空间大（1.4GB / 700MB）
// - 使用标记清除 + 标记整理
// - 回收较慢，频率低

// 对象晋升：
// 新生代对象经过两次 GC 仍存活 → 晋升到老生代
// 或新生代空间不足时提前晋升
```

### 4.3 Scavenge 算法（复制算法）

```js
// 新生代使用 Scavenge（复制算法）

// 新生代分为两个空间：
// - From 空间：存放活动对象
// - To 空间：空闲

// GC 过程：
// 1. 从 From 空间复制存活对象到 To 空间
// 2. 清空 From 空间
// 3. From 和 To 空间角色互换

// 优点：
// - 速度快（只处理存活对象）
// - 没有碎片（紧凑排列）

// 缺点：
// - 只能使用一半空间
// - 需要复制对象

// 内存布局：
// Before GC:
// From: [A][B][ ][C]
// To:   [ ][ ][ ][ ]
// 
// After GC:
// From: [ ][ ][ ][ ]  （清空）
// To:   [A][B][C][ ]  （存活对象）
```

---

## 五、增量标记（Incremental Marking）

### 5.1 解决 STW 问题

```js
// Stop-The-World（STW）：GC 期间程序暂停
// 对于大堆，STW 时间可能很长，影响用户体验

// 增量标记：将标记工作分成小块
// 程序执行 → 标记一部分 → 程序执行 → 标记一部分 → ...

// 优点：
// - 减少单次暂停时间
// - 提高响应性

// 缺点：
// - 总 GC 时间可能增加
// - 需要写屏障（Write Barrier）追踪修改

// 时间线：
// ████ 程序执行
// ░░░░ GC 工作
// 
// 传统 GC：
// ████████░░░░░░░░████████
// 
// 增量 GC：
// ████░░████░░████░░████░░
```

### 5.2 三色标记

```js
// 增量标记使用三色标记算法

// 白色：未访问的对象（默认）
// 灰色：已访问但未遍历其引用的对象
// 黑色：已访问且已遍历其引用的对象

// 标记过程：
// 1. 初始：所有对象为白色
// 2. 将根对象标记为灰色
// 3. 从灰色对象开始：
//    - 遍历其引用的对象，标记为灰色
//    - 自身标记为黑色
// 4. 重复直到没有灰色对象
// 5. 清除所有白色对象

// 示例：
// Root → A → B
//        ↓
//        C
// 
// 步骤：
// 1. 白色：A, B, C    灰色：Root  黑色：-
// 2. 白色：B, C       灰色：A     黑色：Root
// 3. 白色：C          灰色：B     黑色：Root, A
// 4. 白色：-          灰色：C     黑色：Root, A, B
// 5. 白色：-          灰色：-     黑色：Root, A, B, C
```

---

## 六、并发标记（Concurrent Marking）

### 6.1 Orinoco 垃圾回收器

```js
// V8 的 Orinoco：并发、并行、增量的 GC

// 1. 并发（Concurrent）
// - GC 线程与主线程同时运行
// - 主线程继续执行 JavaScript
// - 标记和清除可以并发进行

// 2. 并行（Parallel）
// - 多个 GC 线程同时工作
// - 加速 GC 过程

// 3. 增量（Incremental）
// - 分批次执行
// - 减少暂停时间

// 效果：
// - 主要 GC 工作在后台完成
// - 主线程暂停时间显著减少（< 10ms）
```

---

## 七、写屏障（Write Barrier）

### 7.1 解决并发问题

```js
// 并发 GC 的问题：
// GC 标记期间，程序可能修改对象引用

// 示例问题：
// 1. 黑色对象 A 引用白色对象 C
// 2. GC 认为 A 已完成，不会再访问
// 3. C 会被错误回收

// 解决：写屏障
// 每次写入对象引用时，记录修改
// GC 会重新检查这些修改

// 伪代码：
function writeBarrier(object, field, value) {
  // 记录修改
  if (isMarking && isBlack(object) && isWhite(value)) {
    markGrey(value);  // 重新标记为灰色
  }

  // 执行写入
  object[field] = value;
}
```

---

## 八、最佳实践

1. **避免频繁创建大对象**：减轻 GC 压力。
2. **及时解除引用**：不再使用的对象设为 `null`。
3. **对象池复用**：频繁创建的对象用对象池。
4. **避免内存泄漏**：定时器、事件监听器及时清理。
5. **监控内存使用**：使用 DevTools 查看内存增长。

---

## 参考资料

- [V8 Blog - Trash Talk](https://v8.dev/blog/trash-talk)
- [V8 Blog - Concurrent Marking](https://v8.dev/blog/concurrent-marking)
- [MDN - Memory Management](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Memory_Management)
