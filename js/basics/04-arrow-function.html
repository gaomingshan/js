<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>箭头函数详解 - JavaScript 深度学习</title>
    <link rel="stylesheet" href="../assets/css/main.css">
    <link rel="stylesheet" href="../assets/css/page.css">
</head>
<body>
    <div class="page-layout">
        <div class="doc-panel">
            <h1>箭头函数详解</h1>
            
            <h2>概述</h2>
            <p>箭头函数（Arrow Function）是 ES6 引入的新语法，提供了更简洁的函数写法，并且有独特的 <code>this</code> 绑定行为。</p>
            
            <h2>一、基本语法</h2>
            
            <h3>1.1 语法形式</h3>
            <pre><code>// 基本形式
(param1, param2) => { 函数体 }

// 单个参数可以省略括号
param => { 函数体 }

// 无参数必须使用空括号
() => { 函数体 }

// 单表达式可以省略花括号和 return
param => expression

// 返回对象字面量需要用括号包裹
() => ({ key: value })</code></pre>
            
            <h3>1.2 示例对比</h3>
            <pre><code>// 传统函数
function add(a, b) {
    return a + b;
}

// 箭头函数
const add = (a, b) => a + b;

// 传统函数
const double = function(x) {
    return x * 2;
};

// 箭头函数
const double = x => x * 2;</code></pre>
            
            <h2>二、箭头函数的特点</h2>
            
            <h3>2.1 词法 this</h3>
            <p>箭头函数没有自己的 <code>this</code>，会捕获定义时外层作用域的 <code>this</code>。</p>
            
            <div class="info">
                <strong>关键特性：</strong>
                <ul>
                    <li><code>this</code> 在定义时确定，不在调用时确定</li>
                    <li>无法通过 <code>call</code>、<code>apply</code>、<code>bind</code> 改变</li>
                    <li>永远指向外层作用域的 <code>this</code></li>
                </ul>
            </div>
            
            <h3>2.2 没有 arguments 对象</h3>
            <p>箭头函数没有 <code>arguments</code> 对象，但可以使用剩余参数：</p>
            
            <pre><code>// 传统函数
function sum() {
    return Array.from(arguments).reduce((a, b) => a + b, 0);
}

// 箭头函数（使用剩余参数）
const sum = (...args) => args.reduce((a, b) => a + b, 0);</code></pre>
            
            <h3>2.3 不能用作构造函数</h3>
            <p>箭头函数不能使用 <code>new</code> 调用：</p>
            
            <pre><code>const Person = (name) => {
    this.name = name;
};

new Person('Alice');  // TypeError!</code></pre>
            
            <h3>2.4 没有 prototype 属性</h3>
            <pre><code>const arrow = () => {};
console.log(arrow.prototype);  // undefined

function normal() {}
console.log(normal.prototype);  // { constructor: f }</code></pre>
            
            <h3>2.5 不能用作生成器</h3>
            <p>箭头函数不能使用 <code>yield</code> 关键字：</p>
            
            <pre><code>// 错误
const generator = *() => {
    yield 1;
};</code></pre>
            
            <h2>三、使用场景</h2>
            
            <h3>3.1 数组方法</h3>
            <p>箭头函数最常用于数组的高阶方法：</p>
            
            <pre><code>const numbers = [1, 2, 3, 4, 5];

// map
const doubled = numbers.map(x => x * 2);

// filter
const evens = numbers.filter(x => x % 2 === 0);

// reduce
const sum = numbers.reduce((acc, cur) => acc + cur, 0);</code></pre>
            
            <h3>3.2 回调函数</h3>
            <pre><code>setTimeout(() => {
    console.log('Delayed');
}, 1000);

button.addEventListener('click', () => {
    console.log('Clicked');
});</code></pre>
            
            <h3>3.3 this 绑定</h3>
            <p>在需要保持外层 <code>this</code> 的场景中非常有用：</p>
            
            <pre><code>class Timer {
    constructor() {
        this.seconds = 0;
    }
    
    start() {
        setInterval(() => {
            this.seconds++;  // this 指向 Timer 实例
            console.log(this.seconds);
        }, 1000);
    }
}</code></pre>
            
            <h2>四、箭头函数 vs 普通函数</h2>
            
            <table>
                <thead>
                    <tr>
                        <th>特性</th>
                        <th>箭头函数</th>
                        <th>普通函数</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>this 绑定</td>
                        <td>词法 this（外层）</td>
                        <td>动态 this（调用时）</td>
                    </tr>
                    <tr>
                        <td>arguments</td>
                        <td>无</td>
                        <td>有</td>
                    </tr>
                    <tr>
                        <td>new 调用</td>
                        <td>不可以</td>
                        <td>可以</td>
                    </tr>
                    <tr>
                        <td>prototype</td>
                        <td>无</td>
                        <td>有</td>
                    </tr>
                    <tr>
                        <td>super</td>
                        <td>有（词法）</td>
                        <td>有</td>
                    </tr>
                    <tr>
                        <td>yield</td>
                        <td>不可用</td>
                        <td>可用</td>
                    </tr>
                </tbody>
            </table>
            
            <h2>五、什么时候不用箭头函数</h2>
            
            <h3>5.1 对象方法</h3>
            <div class="warning">
                <pre><code>// 不推荐
const obj = {
    name: 'Alice',
    greet: () => {
        console.log(this.name);  // undefined
    }
};

// 推荐
const obj = {
    name: 'Alice',
    greet() {
        console.log(this.name);  // "Alice"
    }
};</code></pre>
            </div>
            
            <h3>5.2 需要动态 this 的场景</h3>
            <pre><code>// 不推荐
button.addEventListener('click', () => {
    this.classList.toggle('active');  // this 不是 button
});

// 推荐
button.addEventListener('click', function() {
    this.classList.toggle('active');  // this 是 button
});</code></pre>
            
            <h3>5.3 需要 arguments 的场景</h3>
            <pre><code>// 不推荐（除非使用剩余参数）
const func = () => {
    console.log(arguments);  // ReferenceError
};

// 推荐
function func() {
    console.log(arguments);
}

// 或使用剩余参数
const func = (...args) => {
    console.log(args);
};</code></pre>
            
            <h3>5.4 原型方法</h3>
            <pre><code>// 不推荐
Person.prototype.greet = () => {
    return `Hello, ${this.name}`;  // this 不是实例
};

// 推荐
Person.prototype.greet = function() {
    return `Hello, ${this.name}`;
};</code></pre>
            
            <h2>六、高级用法</h2>
            
            <h3>6.1 立即执行箭头函数</h3>
            <pre><code>(() => {
    console.log('IIFE with arrow function');
})();</code></pre>
            
            <h3>6.2 返回对象字面量</h3>
            <pre><code>// 错误（会被解析为代码块）
const getObj = () => { name: 'Alice' };

// 正确（用括号包裹）
const getObj = () => ({ name: 'Alice' });</code></pre>
            
            <h3>6.3 链式调用</h3>
            <pre><code>const result = [1, 2, 3, 4, 5]
    .map(x => x * 2)
    .filter(x => x > 5)
    .reduce((acc, cur) => acc + cur, 0);</code></pre>
            
            <h3>6.4 高阶函数</h3>
            <pre><code>// 返回箭头函数的箭头函数
const multiply = x => y => x * y;

const double = multiply(2);
console.log(double(5));  // 10</code></pre>
            
            <h2>七、性能考虑</h2>
            
            <div class="info">
                <ul>
                    <li>箭头函数比普通函数略快（没有 <code>this</code> 绑定开销）</li>
                    <li>但差异微乎其微，可以忽略</li>
                    <li>优先考虑代码可读性和正确性</li>
                    <li>在热点代码中可以考虑性能测试</li>
                </ul>
            </div>
            
            <h2>八、最佳实践</h2>
            
            <div class="tip">
                <ol>
                    <li><strong>默认使用箭头函数</strong>：用于回调、数组方法</li>
                    <li><strong>对象方法用普通函数</strong>：需要动态 <code>this</code></li>
                    <li><strong>简洁语法</strong>：单参数、单表达式时省略括号和 return</li>
                    <li><strong>可读性优先</strong>：复杂逻辑使用完整语法</li>
                    <li><strong>一致性</strong>：团队统一风格</li>
                </ol>
            </div>
            
            <h2>参考资料</h2>
            <ul>
                <li><a href="https://tc39.es/ecma262/#sec-arrow-function-definitions" target="_blank">ECMAScript - Arrow Function Definitions</a></li>
                <li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/Arrow_functions" target="_blank">MDN - 箭头函数</a></li>
                <li><a href="https://exploringjs.com/es6/ch_arrow-functions.html" target="_blank">Exploring ES6 - Arrow Functions</a></li>
            </ul>
            
            <div class="nav-links">
                <a href="04-this.html" class="nav-link prev">上一节：this 绑定规则</a>
                <a href="../index.html" class="nav-link home">返回首页</a>
                <a href="04-function-advanced.html" class="nav-link next">下一节：高阶函数</a>
            </div>
        </div>
        
        <div class="code-panel">
            <h2 style="color: #60a5fa; margin-bottom: 1.5rem;">💻 交互式代码示例</h2>
            
            <div class="code-example">
                <h3>示例 1：基本语法</h3>
                <div class="code-block">
                    <pre><code>// 无参数
const greet = () => 'Hello!';
console.log(greet());

// 单个参数
const double = x => x * 2;
console.log('double(5):', double(5));

// 多个参数
const add = (a, b) => a + b;
console.log('add(3, 4):', add(3, 4));

// 函数体
const multiply = (a, b) => {
    const result = a * b;
    return result;
};
console.log('multiply(3, 4):', multiply(3, 4));

// 返回对象字面量（需要括号）
const getUser = () => ({ name: 'Alice', age: 25 });
console.log('getUser():', getUser());</code></pre>
                </div>
                <button class="run-btn">▶ 运行代码</button>
                <div class="output"></div>
            </div>
            
            <div class="code-example">
                <h3>示例 2：this 绑定</h3>
                <div class="code-block">
                    <pre><code>// 普通函数 vs 箭头函数
const obj = {
    name: 'Alice',
    
    // 普通函数 - this 指向 obj
    greet1: function() {
        console.log('普通函数 this.name:', this.name);
    },
    
    // 箭头函数 - this 指向外层（window/global）
    greet2: () => {
        console.log('箭头函数 this.name:', this.name);
    },
    
    // 嵌套情况
    test: function() {
        console.log('\n嵌套情况:');
        console.log('外层 this.name:', this.name);
        
        // 普通函数
        setTimeout(function() {
            console.log('setTimeout 普通函数:', this.name);
        }, 10);
        
        // 箭头函数
        setTimeout(() => {
            console.log('setTimeout 箭头函数:', this.name);
        }, 20);
    }
};

obj.greet1();
obj.greet2();
obj.test();</code></pre>
                </div>
                <button class="run-btn">▶ 运行代码</button>
                <div class="output"></div>
            </div>
            
            <div class="code-example">
                <h3>示例 3：数组方法</h3>
                <div class="code-block">
                    <pre><code>const numbers = [1, 2, 3, 4, 5];

// map
const doubled = numbers.map(x => x * 2);
console.log('doubled:', doubled);

// filter
const evens = numbers.filter(x => x % 2 === 0);
console.log('evens:', evens);

// reduce
const sum = numbers.reduce((acc, cur) => acc + cur, 0);
console.log('sum:', sum);

// 链式调用
const result = numbers
    .filter(x => x > 2)      // [3, 4, 5]
    .map(x => x * 2)         // [6, 8, 10]
    .reduce((a, b) => a + b, 0);  // 24
console.log('链式调用结果:', result);

// 复杂数据处理
const users = [
    { name: 'Alice', age: 25 },
    { name: 'Bob', age: 30 },
    { name: 'Charlie', age: 28 }
];

const names = users
    .filter(u => u.age >= 28)
    .map(u => u.name);
console.log('年龄>=28的用户:', names);</code></pre>
                </div>
                <button class="run-btn">▶ 运行代码</button>
                <div class="output"></div>
            </div>
            
            <div class="code-example">
                <h3>示例 4：高阶函数</h3>
                <div class="code-block">
                    <pre><code>// 返回函数的函数
const multiply = x => y => x * y;

const double = multiply(2);
const triple = multiply(3);

console.log('double(5):', double(5));
console.log('triple(5):', triple(5));

// 函数组合
const add = x => y => x + y;
const add5 = add(5);

console.log('\nadd5(10):', add5(10));

// 实用工具函数
const pipe = (...funcs) => x => 
    funcs.reduce((acc, func) => func(acc), x);

const addOne = x => x + 1;
const multiplyTwo = x => x * 2;
const square = x => x * x;

const transform = pipe(addOne, multiplyTwo, square);
console.log('\npipe(5):', transform(5));
// (5 + 1) * 2 = 12, 12^2 = 144</code></pre>
                </div>
                <button class="run-btn">▶ 运行代码</button>
                <div class="output"></div>
            </div>
            
            <div class="code-example">
                <h3>示例 5：常见陷阱</h3>
                <div class="code-block">
                    <pre><code>// 陷阱1：对象方法
const obj1 = {
    name: 'Alice',
    greet: () => {
        console.log('陷阱1 - this.name:', this.name);  // undefined
    }
};
obj1.greet();

// 正确：使用普通函数或方法简写
const obj2 = {
    name: 'Bob',
    greet() {
        console.log('正确 - this.name:', this.name);
    }
};
obj2.greet();

// 陷阱2：返回对象字面量
const wrong = () => { name: 'Alice' };  // 返回 undefined
const right = () => ({ name: 'Alice' });

console.log('\n陷阱2:');
console.log('wrong():', wrong());
console.log('right():', right());

// 陷阱3：arguments
const arrowFunc = () => {
    try {
        console.log(arguments);
    } catch (e) {
        console.log('\n陷阱3 - 箭头函数无 arguments:', e.message);
    }
};
arrowFunc(1, 2, 3);

// 正确：使用剩余参数
const correctFunc = (...args) => {
    console.log('剩余参数:', args);
};
correctFunc(1, 2, 3);</code></pre>
                </div>
                <button class="run-btn">▶ 运行代码</button>
                <div class="output"></div>
            </div>
            
            <div class="code-example">
                <h3>示例 6：实用技巧</h3>
                <div class="code-block">
                    <pre><code>// 技巧1：默认参数
const greet = (name = 'Guest') => `Hello, ${name}!`;
console.log(greet());
console.log(greet('Alice'));

// 技巧2：解构参数
const getFullName = ({ firstName, lastName }) => 
    `${firstName} ${lastName}`;

console.log('\n解构参数:');
console.log(getFullName({ firstName: 'Alice', lastName: 'Smith' }));

// 技巧3：条件返回
const getStatus = score => 
    score >= 90 ? 'A' :
    score >= 80 ? 'B' :
    score >= 70 ? 'C' : 'D';

console.log('\n条件返回:');
console.log('getStatus(85):', getStatus(85));

// 技巧4：立即执行
(() => {
    console.log('\n立即执行箭头函数');
})();

// 技巧5：数组去重
const unique = arr => [...new Set(arr)];
console.log('unique([1,2,2,3,3,3]):', unique([1,2,2,3,3,3]));

// 技巧6：对象属性过滤
const pickProps = (obj, ...keys) => 
    keys.reduce((acc, key) => ({
        ...acc,
        [key]: obj[key]
    }), {});

const user = { id: 1, name: 'Alice', age: 25, email: 'alice@example.com' };
console.log('\npickProps:', pickProps(user, 'name', 'age'));</code></pre>
                </div>
                <button class="run-btn">▶ 运行代码</button>
                <div class="output"></div>
            </div>
        </div>
    </div>
    
    <script src="../assets/js/common.js"></script>
</body>
</html>
