<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Promise/A+ 规范详解 - JavaScript 深度学习</title>
    <link rel="stylesheet" href="../assets/css/main.css">
    <link rel="stylesheet" href="../assets/css/page.css">
</head>
<body>
    <div class="page-layout">
        <div class="doc-panel">
            <h1>Promise/A+ 规范详解</h1>
            
            <h2>概述</h2>
            <p>Promise/A+ 是一个开放标准，定义了 Promise 的核心行为。ECMAScript 2015 (ES6) 引入的原生 Promise 遵循这个规范。</p>
            
            <div class="spec">
                <strong>Promise/A+ 规范核心：</strong>
                定义了 Promise 的三个状态、then 方法的行为、以及 Promise 解析过程的详细算法。
            </div>
            
            <h2>一、Promise 的状态机</h2>
            
            <h3>1.1 三种状态</h3>
            <ul>
                <li><strong>Pending（等待态）</strong>：初始状态，可以转换为 fulfilled 或 rejected</li>
                <li><strong>Fulfilled（完成态）</strong>：操作成功，有一个不可变的终值（value）</li>
                <li><strong>Rejected（拒绝态）</strong>：操作失败，有一个不可变的原因（reason）</li>
            </ul>
            
            <div class="spec">
                <strong>状态转换规则：</strong>
                <pre>pending → fulfilled (不可逆)
pending → rejected  (不可逆)

一旦 Promise 状态改变，就永远不会再变。</pre>
            </div>
            
            <h3>1.2 内部槽位</h3>
            <p>Promise 对象包含以下内部槽位：</p>
            
            <div class="spec">
                <strong>Promise 内部槽位（ECMAScript 规范）：</strong>
                <pre>[[PromiseState]]        - "pending" | "fulfilled" | "rejected"
[[PromiseResult]]       - Promise 的值或原因
[[PromiseFulfillReactions]] - 完成时的回调队列
[[PromiseRejectReactions]]  - 拒绝时的回调队列
[[PromiseIsHandled]]    - 是否已处理拒绝</pre>
            </div>
            
            <h2>二、then 方法规范</h2>
            
            <h3>2.1 then 方法签名</h3>
            <pre><code>promise.then(onFulfilled, onRejected)</code></pre>
            
            <div class="spec">
                <strong>then 方法要求：</strong>
                <ul>
                    <li>onFulfilled 和 onRejected 都是可选参数</li>
                    <li>如果不是函数，必须被忽略</li>
                    <li>必须返回一个新的 Promise</li>
                    <li>可以被同一个 Promise 调用多次</li>
                    <li>回调必须异步执行（微任务）</li>
                </ul>
            </div>
            
            <h3>2.2 回调执行时机</h3>
            <ul>
                <li>onFulfilled 在 Promise 变为 fulfilled 后调用，value 作为第一个参数</li>
                <li>onRejected 在 Promise 变为 rejected 后调用，reason 作为第一个参数</li>
                <li>在执行上下文栈只包含平台代码之前不得调用（即异步执行）</li>
                <li>必须作为函数调用（即没有 this 值）</li>
                <li>每个回调最多被调用一次</li>
            </ul>
            
            <h3>2.3 链式调用</h3>
            <p>then 方法返回新 Promise 的值取决于回调的返回值：</p>
            
            <div class="spec">
                <strong>Promise 解析过程（[[Resolve]](promise, x)）：</strong>
                <pre>1. 如果 promise 和 x 指向同一对象
   → 以 TypeError 拒绝 promise

2. 如果 x 是一个 Promise
   → 采用 x 的状态

3. 如果 x 是对象或函数
   → 尝试获取 x.then
   → 如果 then 是函数，调用它
   → 否则，以 x 完成 promise

4. 如果 x 不是对象或函数
   → 以 x 完成 promise</pre>
            </div>
            
            <h2>三、Promise 构造器</h2>
            
            <h3>3.1 构造函数语法</h3>
            <pre><code>new Promise(executor)
// executor: (resolve, reject) => void</code></pre>
            
            <h3>3.2 执行器的执行时机</h3>
            <ul>
                <li>executor 在 Promise 构造器返回前同步执行</li>
                <li>executor 接收 resolve 和 reject 两个函数参数</li>
                <li>如果 executor 抛出错误，Promise 会被拒绝</li>
            </ul>
            
            <h2>四、Promise 静态方法</h2>
            
            <h3>4.1 Promise.resolve()</h3>
            <div class="spec">
                <strong>算法：</strong>
                <ul>
                    <li>如果参数是 Promise，直接返回</li>
                    <li>如果参数是 thenable，返回跟随该 thenable 的 Promise</li>
                    <li>否则，返回以该值完成的 Promise</li>
                </ul>
            </div>
            
            <h3>4.2 Promise.reject()</h3>
            <p>返回一个以给定原因拒绝的 Promise。</p>
            
            <h3>4.3 Promise.all()</h3>
            <div class="spec">
                <strong>行为：</strong>
                <ul>
                    <li>等待所有 Promise 完成，或任一 Promise 拒绝</li>
                    <li>如果全部完成，返回值数组</li>
                    <li>如果任一拒绝，立即拒绝并返回第一个拒绝原因</li>
                </ul>
            </div>
            
            <h3>4.4 Promise.race()</h3>
            <p>返回第一个完成或拒绝的 Promise 的结果。</p>
            
            <h3>4.5 Promise.allSettled()（ES2020）</h3>
            <p>等待所有 Promise 完成（无论成功或失败），返回状态数组。</p>
            
            <h3>4.6 Promise.any()（ES2021）</h3>
            <p>等待第一个 fulfilled 的 Promise，如果全部 rejected 则抛出 AggregateError。</p>
            
            <h2>五、微任务队列</h2>
            
            <h3>5.1 Promise 回调的执行</h3>
            <p>Promise 的回调（onFulfilled/onRejected）被放入微任务队列（Microtask Queue）。</p>
            
            <div class="spec">
                <strong>ECMAScript 规范：</strong>
                Promise 回调通过 HostEnqueuePromiseJob 抽象操作加入到 Job Queue（微任务队列）。
            </div>
            
            <h3>5.2 执行顺序</h3>
            <pre><code>同步代码 → 微任务队列 → 宏任务队列

微任务优先于宏任务执行。</code></pre>
            
            <h2>六、常见陷阱与误区</h2>
            
            <h3>6.1 Promise 构造函数陷阱</h3>
            <div class="warning">
                <strong>反模式：Promise 构造器反模式</strong>
                <pre><code>// ❌ 不要这样做
function getUserData(id) {
    return new Promise((resolve, reject) => {
        fetchUser(id)  // 已经返回 Promise
            .then(user => resolve(user))
            .catch(err => reject(err));
    });
}

// ✅ 正确做法
function getUserData(id) {
    return fetchUser(id);
}</code></pre>
            </div>
            
            <h3>6.2 then 方法的穿透</h3>
            <p>如果 then 的参数不是函数，会发生值穿透：</p>
            
            <h3>6.3 错误处理</h3>
            <div class="warning">
                未捕获的 Promise 拒绝会导致 <code>unhandledRejection</code> 事件（Node.js）或控制台警告（浏览器）。
            </div>
            
            <h2>七、手动实现 Promise</h2>
            
            <div class="info">
                理解 Promise 的最好方式是手动实现一个符合 Promise/A+ 规范的 Promise 类。右侧代码示例展示了核心实现。
            </div>
            
            <h2>八、性能考虑</h2>
            
            <div class="tip">
                <ul>
                    <li><strong>避免过长的链</strong>：每个 then 都会创建新 Promise</li>
                    <li><strong>使用 Promise.all</strong>：并行执行多个异步操作</li>
                    <li><strong>避免同步包装</strong>：不要用 Promise 包装同步操作</li>
                    <li><strong>及时处理错误</strong>：避免创建未处理的拒绝</li>
                </ul>
            </div>
            
            <h2>参考资料</h2>
            <ul>
                <li><a href="https://promisesaplus.com/" target="_blank">Promise/A+ 规范</a></li>
                <li><a href="https://tc39.es/ecma262/#sec-promise-objects" target="_blank">ECMAScript - Promise Objects</a></li>
                <li><a href="https://tc39.es/ecma262/#sec-promise-jobs" target="_blank">ECMAScript - Promise Jobs</a></li>
                <li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise" target="_blank">MDN - Promise</a></li>
            </ul>
            
            <div class="nav-links">
                <a href="../index.html" class="nav-link home">返回首页</a>
                <a href="18-thenable.html" class="nav-link next">下一节：Thenable 协议</a>
            </div>
        </div>
        
        <div class="code-panel">
            <h2 style="color: #60a5fa; margin-bottom: 1.5rem;">💻 交互式代码示例</h2>
            
            <!-- 示例1: Promise 状态 -->
            <div class="code-example">
                <h3>示例 1：Promise 状态转换</h3>
                <div class="code-block">
                    <pre><code>// Pending → Fulfilled
const p1 = new Promise((resolve) => {
    console.log('Promise 创建（pending）');
    setTimeout(() => {
        resolve('成功');
        console.log('Promise 已完成（fulfilled）');
    }, 100);
});

p1.then(value => console.log('结果:', value));

// Pending → Rejected
const p2 = new Promise((resolve, reject) => {
    setTimeout(() => {
        reject('失败');
        console.log('Promise 已拒绝（rejected）');
    }, 200);
});

p2.catch(reason => console.log('错误:', reason));</code></pre>
                </div>
                <button class="run-btn">▶ 运行代码</button>
                <div class="output"></div>
            </div>
            
            <!-- 示例2: then 链式调用 -->
            <div class="code-example">
                <h3>示例 2：then 链式调用</h3>
                <div class="code-block">
                    <pre><code>Promise.resolve(1)
    .then(x => {
        console.log('第一步:', x);
        return x + 1;
    })
    .then(x => {
        console.log('第二步:', x);
        return x * 2;
    })
    .then(x => {
        console.log('第三步:', x);
        return x + 3;
    })
    .then(result => {
        console.log('最终结果:', result);  // 7
    });</code></pre>
                </div>
                <button class="run-btn">▶ 运行代码</button>
                <div class="output"></div>
            </div>
            
            <!-- 示例3: 值穿透 -->
            <div class="code-example">
                <h3>示例 3：值穿透现象</h3>
                <div class="code-block">
                    <pre><code>Promise.resolve(42)
    .then('不是函数')     // 被忽略
    .then(null)           // 被忽略
    .then(value => {
        console.log('穿透后的值:', value);  // 42
        return value * 2;
    })
    .then(undefined)      // 被忽略
    .then(console.log);   // 84</code></pre>
                </div>
                <button class="run-btn">▶ 运行代码</button>
                <div class="output"></div>
            </div>
            
            <!-- 示例4: Promise.all -->
            <div class="code-example">
                <h3>示例 4：Promise.all 用法</h3>
                <div class="code-block">
                    <pre><code>const p1 = Promise.resolve(1);
const p2 = new Promise(resolve => setTimeout(() => resolve(2), 100));
const p3 = Promise.resolve(3);

Promise.all([p1, p2, p3])
    .then(values => {
        console.log('所有 Promise 完成:', values);  // [1, 2, 3]
    });

// 失败案例
const p4 = Promise.resolve(4);
const p5 = Promise.reject('错误');
const p6 = Promise.resolve(6);

Promise.all([p4, p5, p6])
    .then(values => {
        console.log('不会执行');
    })
    .catch(reason => {
        console.log('捕获到第一个错误:', reason);  // '错误'
    });</code></pre>
                </div>
                <button class="run-btn">▶ 运行代码</button>
                <div class="output"></div>
            </div>
            
            <!-- 示例5: Promise.race -->
            <div class="code-example">
                <h3>示例 5：Promise.race 竞速</h3>
                <div class="code-block">
                    <pre><code>const slow = new Promise(resolve => 
    setTimeout(() => resolve('慢'), 200)
);

const fast = new Promise(resolve => 
    setTimeout(() => resolve('快'), 100)
);

Promise.race([slow, fast])
    .then(result => {
        console.log('获胜者:', result);  // '快'
    });

// 超时控制应用
function timeout(ms) {
    return new Promise((_, reject) =>
        setTimeout(() => reject('超时'), ms)
    );
}

function fetchWithTimeout(url, ms) {
    return Promise.race([
        fetch(url),
        timeout(ms)
    ]);
}

console.log('超时控制函数已定义');</code></pre>
                </div>
                <button class="run-btn">▶ 运行代码</button>
                <div class="output"></div>
            </div>
            
            <!-- 示例6: 简化版 Promise 实现 -->
            <div class="code-example">
                <h3>示例 6：简化版 Promise 实现</h3>
                <div class="code-block">
                    <pre><code>class MyPromise {
    constructor(executor) {
        this.state = 'pending';
        this.value = undefined;
        this.callbacks = [];
        
        const resolve = (value) => {
            if (this.state === 'pending') {
                this.state = 'fulfilled';
                this.value = value;
                this.callbacks.forEach(cb => cb.onFulfilled(value));
            }
        };
        
        const reject = (reason) => {
            if (this.state === 'pending') {
                this.state = 'rejected';
                this.value = reason;
                this.callbacks.forEach(cb => cb.onRejected(reason));
            }
        };
        
        try {
            executor(resolve, reject);
        } catch (error) {
            reject(error);
        }
    }
    
    then(onFulfilled, onRejected) {
        return new MyPromise((resolve, reject) => {
            const handle = () => {
                try {
                    if (this.state === 'fulfilled') {
                        const result = onFulfilled ? onFulfilled(this.value) : this.value;
                        resolve(result);
                    } else if (this.state === 'rejected') {
                        const result = onRejected ? onRejected(this.value) : this.value;
                        reject(result);
                    }
                } catch (error) {
                    reject(error);
                }
            };
            
            if (this.state === 'pending') {
                this.callbacks.push({
                    onFulfilled: (value) => {
                        setTimeout(() => {
                            try {
                                const result = onFulfilled ? onFulfilled(value) : value;
                                resolve(result);
                            } catch (error) {
                                reject(error);
                            }
                        }, 0);
                    },
                    onRejected: (reason) => {
                        setTimeout(() => {
                            try {
                                const result = onRejected ? onRejected(reason) : reason;
                                resolve(result);
                            } catch (error) {
                                reject(error);
                            }
                        }, 0);
                    }
                });
            } else {
                setTimeout(handle, 0);
            }
        });
    }
}

// 测试
const mp = new MyPromise((resolve) => {
    setTimeout(() => resolve('MyPromise 完成'), 100);
});

mp.then(value => {
    console.log(value);
    return value + '!';
}).then(value => {
    console.log(value);
});</code></pre>
                </div>
                <button class="run-btn">▶ 运行代码</button>
                <div class="output"></div>
            </div>
        </div>
    </div>
    
    <script src="../assets/js/common.js"></script>
</body>
</html>
