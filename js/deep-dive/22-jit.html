<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JIT 编译优化 - JavaScript 深度学习</title>
    <link rel="stylesheet" href="../assets/css/main.css">
    <link rel="stylesheet" href="../assets/css/page.css">
</head>
<body>
    <div class="page-layout">
        <div class="doc-panel">
            <h1>JIT 编译优化</h1>
            
            <h2>概述</h2>
            <p>JIT（Just-In-Time）即时编译是 V8 提升 JavaScript 性能的核心技术。它在运行时将热点代码编译为优化的机器码，实现接近原生代码的执行速度。</p>
            
            <h2>一、JIT 编译原理</h2>
            
            <h3>1.1 编译流程</h3>
            <pre><code>// V8 的 JIT 编译流程

解释执行（Ignition）
  ↓
收集类型反馈
  ↓
检测热点代码
  ↓
优化编译（TurboFan）
  ↓
执行优化后的机器码
  ↓
类型假设失败？
  ↓
去优化，回到解释执行</code></pre>
            
            <h3>1.2 为什么需要 JIT</h3>
            <div class="info">
                <p><strong>传统方式</strong>：</p>
                <ul>
                    <li><strong>纯解释</strong>：慢，但启动快</li>
                    <li><strong>AOT 编译</strong>：快，但启动慢，占用空间大</li>
                </ul>
                
                <p><strong>JIT 优势</strong>：</p>
                <ul>
                    <li>启动快（先解释执行）</li>
                    <li>运行快（热点代码编译）</li>
                    <li>动态优化（基于实际类型）</li>
                </ul>
            </div>
            
            <h2>二、类型反馈</h2>
            
            <h3>2.1 收集类型信息</h3>
            <pre><code>// V8 在解释执行时收集类型信息
function add(a, b) {
    return a + b;
}

// 调用 1：数字
add(1, 2);
// V8 记录：a 和 b 是数字

// 调用 2：还是数字
add(3, 4);
// V8 确认：总是数字

// TurboFan 优化：生成针对数字的优化代码
// 直接的整数加法指令，无需类型检查

// 调用 3：字符串
add('hello', 'world');
// 类型假设失败，去优化</code></pre>
            
            <h3>2.2 内联缓存（IC）</h3>
            <pre><code>// IC 记录属性访问的类型信息
function getX(obj) {
    return obj.x;
}

// 调用 1
getX({ x: 1, y: 2 });
// IC 记录：x 在偏移量 0

// 调用 2（相同结构）
getX({ x: 3, y: 4 });
// IC 命中，快速访问

// IC 状态：
// - Uninitialized: 未初始化
// - Monomorphic: 单一类型（最快）
// - Polymorphic: 多种类型（2-4种）
// - Megamorphic: 太多类型（>4种，慢）</code></pre>
            
            <h2>三、优化技术</h2>
            
            <h3>3.1 函数内联</h3>
            <pre><code>// 内联：将函数调用替换为函数体
function square(x) {
    return x * x;
}

function sumOfSquares(a, b) {
    return square(a) + square(b);
}

// 优化前：
// - 调用 square(a)
// - 调用 square(b)
// - 相加

// 优化后（内联）：
// return a * a + b * b
// 消除函数调用开销

// 内联条件：
// - 函数小（通常 <600 字节）
// - 调用频繁
// - 不是递归函数</code></pre>
            
            <h3>3.2 循环优化</h3>
            <pre><code>// 循环展开
function sum(arr) {
    let total = 0;
    for (let i = 0; i < arr.length; i++) {
        total += arr[i];
    }
    return total;
}

// 优化前：每次迭代检查边界
// 优化后：可能展开为
// total += arr[0];
// total += arr[1];
// total += arr[2];
// total += arr[3];
// ...

// 其他循环优化：
// - 边界检查消除
// - 循环不变代码外提
// - 强度削减</code></pre>
            
            <h3>3.3 逃逸分析</h3>
            <pre><code>// 逃逸分析：对象是否逃出函数作用域
function createPoint(x, y) {
    const point = { x, y };
    return point.x + point.y;
}

// point 没有逃逸（不返回对象本身）
// 优化：在栈上分配，不在堆上
// 更快，无需 GC

function createAndReturn(x, y) {
    const point = { x, y };
    return point;
}

// point 逃逸了（返回对象）
// 必须在堆上分配</code></pre>
            
            <h3>3.4 标量替换</h3>
            <pre><code>// 标量替换：用局部变量替换对象
function distance(p1, p2) {
    return Math.sqrt(
        (p1.x - p2.x) ** 2 + 
        (p1.y - p2.y) ** 2
    );
}

// 优化前：访问对象属性
// 优化后：替换为局部变量
// let dx = p1x - p2x;
// let dy = p1y - p2y;
// return Math.sqrt(dx * dx + dy * dy);</code></pre>
            
            <h2>四、去优化（Deoptimization）</h2>
            
            <h3>4.1 触发原因</h3>
            <pre><code>// 去优化的常见原因

// 1. 类型改变
function process(x) {
    return x * 2;
}

process(10);      // 优化为数字运算
process('5');     // 类型改变，去优化

// 2. 隐藏类改变
function Point(x, y) {
    this.x = x;
    this.y = y;
}

const p = new Point(1, 2);
delete p.x;       // 隐藏类改变，去优化

// 3. 数组类型改变
const arr = [1, 2, 3];     // SMI 数组
arr.push('4');             // 变为混合数组，去优化

// 4. 超出优化假设
function bounded(arr) {
    for (let i = 0; i < arr.length; i++) {
        // 假设 arr[i] 总是数字
    }
}

bounded([1, 2, 3]);
bounded([1, 'string', 3]); // 去优化</code></pre>
            
            <h3>4.2 去优化代价</h3>
            <pre><code>// 去优化很昂贵
// 1. 丢弃优化的机器码
// 2. 回到解释执行
// 3. 重新收集类型信息
// 4. 可能再次优化

// 避免去优化：
// - 保持类型一致
// - 不要改变对象结构
// - 预热后再执行关键代码</code></pre>
            
            <h2>五、优化示例</h2>
            
            <h3>5.1 数字运算</h3>
            <pre><code>// 优化良好的数字运算
function calculate(a, b) {
    return (a + b) * (a - b);
}

// 始终用数字调用
for (let i = 0; i < 10000; i++) {
    calculate(i, i + 1);
}

// TurboFan 优化：
// - 类型特化（只处理数字）
// - 内联运算
// - 寄存器分配

// 性能接近原生 C++ 代码</code></pre>
            
            <h3>5.2 对象访问</h3>
            <pre><code>// 单态对象访问
class Vector {
    constructor(x, y) {
        this.x = x;
        this.y = y;
    }
}

function magnitude(v) {
    return Math.sqrt(v.x * v.x + v.y * v.y);
}

// 始终用 Vector 实例调用
for (let i = 0; i < 10000; i++) {
    const v = new Vector(i, i + 1);
    magnitude(v);
}

// TurboFan 优化：
// - 隐藏类检查
// - 直接偏移量访问（无哈希查找）
// - 可能内联 magnitude</code></pre>
            
            <h3>5.3 数组操作</h3>
            <pre><code>// 类型化数组的优化
const arr = new Float64Array(1000);

function processArray(arr) {
    let sum = 0;
    for (let i = 0; i < arr.length; i++) {
        sum += arr[i];
    }
    return sum;
}

// TurboFan 优化：
// - 已知元素类型（Double）
// - 消除边界检查
// - 向量化（SIMD）
// - 循环展开</code></pre>
            
            <h2>六、性能基准</h2>
            
            <h3>6.1 预热效果</h3>
            <pre><code>// 演示预热效果
function benchmark(fn, iterations) {
    // 预热
    for (let i = 0; i < 1000; i++) {
        fn(i);
    }
    
    // 测试
    console.time('optimized');
    for (let i = 0; i < iterations; i++) {
        fn(i);
    }
    console.timeEnd('optimized');
}

function compute(x) {
    return x * x + x * 2 + 1;
}

benchmark(compute, 1000000);</code></pre>
            
            <h3>6.2 类型稳定性</h3>
            <pre><code>// 类型稳定 vs 类型不稳定
function stableAdd(a, b) {
    return a + b;
}

function unstableAdd(a, b) {
    return a + b;
}

// 稳定：始终数字
console.time('stable');
for (let i = 0; i < 1000000; i++) {
    stableAdd(i, i + 1);
}
console.timeEnd('stable');

// 不稳定：混合类型
console.time('unstable');
for (let i = 0; i < 1000000; i++) {
    if (i % 2 === 0) {
        unstableAdd(i, i + 1);      // 数字
    } else {
        unstableAdd('a', 'b');       // 字符串
    }
}
console.timeEnd('unstable');

// stable 会快很多</code></pre>
            
            <h2>七、调试 JIT</h2>
            
            <h3>7.1 V8 标志</h3>
            <pre><code>// Node.js 中查看 JIT 信息

// 查看优化
// node --trace-opt script.js

// 查看去优化
// node --trace-deopt script.js

// 查看 IC 状态
// node --trace-ic script.js

// 允许原生语法
// node --allow-natives-syntax script.js

// 强制优化（测试用）
// %OptimizeFunctionOnNextCall(fn);</code></pre>
            
            <h3>7.2 示例</h3>
            <pre><code>// 使用原生语法检查优化状态
// node --allow-natives-syntax

function add(a, b) {
    return a + b;
}

// 预热
for (let i = 0; i < 10000; i++) {
    add(i, i + 1);
}

// 检查优化状态
// %GetOptimizationStatus(add)
// 1 = 已优化
// 2 = 未优化
// 4 = 总是优化
// 6 = 可能优化</code></pre>
            
            <h2>八、最佳实践</h2>
            
            <div class="tip">
                <ol>
                    <li><strong>保持类型稳定</strong>：函数参数类型一致</li>
                    <li><strong>预热关键函数</strong>：让 JIT 优化</li>
                    <li><strong>避免去优化</strong>：不改变类型和结构</li>
                    <li><strong>使用单态函数</strong>：对象结构一致</li>
                    <li><strong>小函数易内联</strong>：拆分复杂函数</li>
                    <li><strong>基准测试</strong>：验证优化效果</li>
                    <li><strong>信任 V8</strong>：过早优化是万恶之源</li>
                </ol>
            </div>
            
            <h2>参考资料</h2>
            <ul>
                <li><a href="https://v8.dev/docs/turbofan" target="_blank">V8 - TurboFan</a></li>
                <li><a href="https://v8.dev/blog/ignition-interpreter" target="_blank">V8 - Ignition: V8 Interpreter</a></li>
            </ul>
            
            <div class="nav-links">
                <a href="22-v8-internals.html" class="nav-link prev">上一节：V8 内部机制</a>
                <a href="../index.html" class="nav-link home">返回首页</a>
                <a href="22-hidden-class.html" class="nav-link next">下一节：隐藏类与内联缓存</a>
            </div>
        </div>
        
        <div class="code-panel">
            <h2 style="color: #60a5fa; margin-bottom: 1.5rem;">💻 交互式代码示例</h2>
            
            <div class="code-example">
                <h3>示例 1：JIT 预热效果</h3>
                <div class="code-block">
                    <pre><code>// JIT 编译的预热效果
console.log('=== JIT 预热 ===\n');

function compute(x) {
    return x * x + x * 2 + 1;
}

console.log('1. 冷启动（未优化）:');
console.time('cold');
for (let i = 0; i < 1000; i++) {
    compute(i);
}
console.timeEnd('cold');

console.log('\n2. 预热 10000 次...');
for (let i = 0; i < 10000; i++) {
    compute(i);
}

console.log('\n3. 热运行（已优化）:');
console.time('hot');
for (let i = 0; i < 1000; i++) {
    compute(i);
}
console.timeEnd('hot');

console.log('\n说明: 热运行通常更快');
console.log('V8 已编译为优化的机器码');</code></pre>
                </div>
                <button class="run-btn">▶ 运行代码</button>
                <div class="output"></div>
            </div>
            
            <div class="code-example">
                <h3>示例 2：类型稳定性</h3>
                <div class="code-block">
                    <pre><code>// 类型稳定与不稳定的性能对比
console.log('=== 类型稳定性 ===\n');

function add(a, b) {
    return a + b;
}

console.log('1. 类型稳定（数字）:');
console.time('stable');
for (let i = 0; i < 500000; i++) {
    add(i, i + 1);
}
console.timeEnd('stable');

console.log('\n2. 类型不稳定（混合）:');
console.time('unstable');
for (let i = 0; i < 500000; i++) {
    if (i % 2 === 0) {
        add(i, i + 1);
    } else {
        add('a', 'b');
    }
}
console.timeEnd('unstable');

console.log('\n结论:');
console.log('  类型稳定的代码更快');
console.log('  V8 可以生成优化的专用代码');</code></pre>
                </div>
                <button class="run-btn">▶ 运行代码</button>
                <div class="output"></div>
            </div>
            
            <div class="code-example">
                <h3>示例 3：函数内联</h3>
                <div class="code-block">
                    <pre><code>// 小函数容易被内联
console.log('=== 函数内联 ===\n');

function square(x) {
    return x * x;
}

function cube(x) {
    return x * x * x;
}

function compute(x) {
    return square(x) + cube(x);
}

console.log('预热...');
for (let i = 0; i < 10000; i++) {
    compute(i);
}

console.log('\n测试性能:');
console.time('with-inline');
let sum = 0;
for (let i = 0; i < 1000000; i++) {
    sum += compute(i);
}
console.timeEnd('with-inline');

console.log('\n说明:');
console.log('  square 和 cube 可能被内联');
console.log('  减少函数调用开销');</code></pre>
                </div>
                <button class="run-btn">▶ 运行代码</button>
                <div class="output"></div>
            </div>
            
            <div class="code-example">
                <h3>示例 4：去优化触发</h3>
                <div class="code-block">
                    <pre><code>// 去优化的触发
console.log('=== 去优化 ===\n');

function process(x) {
    return x * 2;
}

console.log('1. 预热（数字）:');
for (let i = 0; i < 10000; i++) {
    process(i);
}
console.log('  已优化为数字运算');

console.log('\n2. 正常使用:');
console.time('optimized');
for (let i = 0; i < 100000; i++) {
    process(i);
}
console.timeEnd('optimized');

console.log('\n3. 类型改变:');
console.time('after-deopt');
process('10');  // 触发去优化
for (let i = 0; i < 100000; i++) {
    process(i);
}
console.timeEnd('after-deopt');

console.log('\n说明: 类型改变会触发去优化');</code></pre>
                </div>
                <button class="run-btn">▶ 运行代码</button>
                <div class="output"></div>
            </div>
            
            <div class="code-example">
                <h3>示例 5：单态 vs 多态</h3>
                <div class="code-block">
                    <pre><code>// 单态和多态的性能差异
console.log('=== 单态 vs 多态 ===\n');

function getX(obj) {
    return obj.x;
}

console.log('1. 单态（一种类型）:');
console.time('monomorphic');
for (let i = 0; i < 200000; i++) {
    getX({ x: 1, y: 2 });
    getX({ x: 3, y: 4 });
}
console.timeEnd('monomorphic');

console.log('\n2. 多态（多种类型）:');
console.time('polymorphic');
for (let i = 0; i < 200000; i++) {
    getX({ x: 1 });
    getX({ x: 2, y: 3 });
    getX({ x: 4, y: 5, z: 6 });
}
console.timeEnd('polymorphic');

console.log('\n建议: 保持对象结构一致');</code></pre>
                </div>
                <button class="run-btn">▶ 运行代码</button>
                <div class="output"></div>
            </div>
            
            <div class="code-example">
                <h3>示例 6：数组优化</h3>
                <div class="code-block">
                    <pre><code>// 数组类型对 JIT 优化的影响
console.log('=== 数组优化 ===\n');

function sumArray(arr) {
    let total = 0;
    for (let i = 0; i < arr.length; i++) {
        total += arr[i];
    }
    return total;
}

console.log('1. SMI 数组（小整数）:');
const smiArr = Array(1000).fill(0).map((_, i) => i);
console.time('smi');
for (let i = 0; i < 10000; i++) {
    sumArray(smiArr);
}
console.timeEnd('smi');

console.log('\n2. Double 数组:');
const doubleArr = Array(1000).fill(0).map((_, i) => i + 0.5);
console.time('double');
for (let i = 0; i < 10000; i++) {
    sumArray(doubleArr);
}
console.timeEnd('double');

console.log('\n3. 混合数组:');
const mixedArr = Array(1000).fill(0).map((_, i) => i % 2 ? i : 'x');
console.time('mixed');
for (let i = 0; i < 10000; i++) {
    sumArray(mixedArr);
}
console.timeEnd('mixed');

console.log('\n类型化数组最快');</code></pre>
                </div>
                <button class="run-btn">▶ 运行代码</button>
                <div class="output"></div>
            </div>
        </div>
    </div>
    
    <script src="../assets/js/common.js"></script>
</body>
</html>
