<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>迭代器协议（Iterator Protocol） - JavaScript 深度学习</title>
    <link rel="stylesheet" href="../assets/css/main.css">
    <link rel="stylesheet" href="../assets/css/page.css">
</head>
<body>
    <div class="page-layout">
        <div class="doc-panel">
            <h1>迭代器协议（Iterator Protocol）</h1>
            
            <h2>概述</h2>
            <p>迭代器协议（Iterator Protocol）是 ECMAScript 规范定义的一种接口规范，它定义了产生值序列的标准方式。这是 JavaScript 实现统一迭代机制的基础。</p>
            
            <div class="spec">
                <strong>ECMAScript 规范定义：</strong>
                迭代器协议定义了一个标准的方法来产生一个有限或无限的值序列，并且当所有值都被生成后，能够返回一个最终的完成状态。
            </div>
            
            <h2>一、迭代器协议的核心概念</h2>
            
            <h3>1.1 两个关键协议</h3>
            <ul>
                <li><strong>迭代器协议（Iterator Protocol）</strong>：定义了如何产生值序列</li>
                <li><strong>可迭代协议（Iterable Protocol）</strong>：定义了如何使对象可迭代</li>
            </ul>
            
            <h3>1.2 迭代器对象规范</h3>
            <p>一个对象要成为迭代器，必须实现 <code>next()</code> 方法：</p>
            
            <div class="spec">
                <strong>next() 方法规范：</strong>
                <pre>interface Iterator {
    next(value?: any): IteratorResult;
}

interface IteratorResult {
    done: boolean;    // true 表示迭代完成
    value: any;       // 当前迭代值
}</pre>
            </div>
            
            <h3>1.3 可迭代对象规范</h3>
            <p>一个对象要成为可迭代对象，必须实现 <code>[Symbol.iterator]</code> 方法：</p>
            
            <div class="spec">
                <strong>[Symbol.iterator] 方法规范：</strong>
                <pre>interface Iterable {
    [Symbol.iterator](): Iterator;
}</pre>
            </div>
            
            <h2>二、迭代器的工作原理</h2>
            
            <h3>2.1 迭代器状态机</h3>
            <p>迭代器本质上是一个状态机，包含以下状态：</p>
            
            <ul>
                <li><strong>Active（活跃）</strong>：可以继续产生值</li>
                <li><strong>Completed（完成）</strong>：已产生所有值</li>
                <li><strong>Suspended（暂停）</strong>：等待下一次 next() 调用</li>
            </ul>
            
            <h3>2.2 迭代过程</h3>
            <pre><code>1. 调用对象的 [Symbol.iterator]() 方法，获取迭代器
2. 重复调用迭代器的 next() 方法
3. 每次调用返回 { value, done } 对象
4. 当 done 为 true 时，迭代结束</code></pre>
            
            <h3>2.3 迭代器的消费</h3>
            <p>JavaScript 提供了多种方式消费迭代器：</p>
            
            <ul>
                <li><code>for...of</code> 循环</li>
                <li>扩展运算符 <code>...</code></li>
                <li><code>Array.from()</code></li>
                <li>解构赋值</li>
                <li><code>Promise.all() / Promise.race()</code></li>
                <li><code>yield*</code> 表达式</li>
            </ul>
            
            <h2>三、内置可迭代对象</h2>
            
            <h3>3.1 原生支持迭代器的类型</h3>
            <ul>
                <li><code>Array</code></li>
                <li><code>String</code></li>
                <li><code>Map</code></li>
                <li><code>Set</code></li>
                <li><code>TypedArray</code></li>
                <li><code>arguments</code> 对象</li>
                <li><code>NodeList</code>（DOM 集合）</li>
            </ul>
            
            <h3>3.2 不可迭代的类型</h3>
            <ul>
                <li>普通对象 <code>{}</code></li>
                <li><code>Object.prototype</code></li>
            </ul>
            
            <div class="note">
                普通对象不可迭代的原因：对象属性没有固有的顺序（ES2015 前），且遍历对象有多种方式（keys/values/entries）。
            </div>
            
            <h2>四、迭代器的高级特性</h2>
            
            <h3>4.1 可选方法</h3>
            <p>迭代器除了必需的 <code>next()</code> 方法外，还可以实现两个可选方法：</p>
            
            <div class="spec">
                <strong>return(value?) 方法：</strong>
                <ul>
                    <li>用于提前终止迭代器</li>
                    <li>在 break、return、throw 语句时调用</li>
                    <li>应该返回 { done: true, value: value }</li>
                </ul>
                
                <strong>throw(exception) 方法：</strong>
                <ul>
                    <li>用于向迭代器注入错误</li>
                    <li>主要用于生成器</li>
                    <li>可以在迭代器内部抛出异常</li>
                </ul>
            </div>
            
            <h3>4.2 无限迭代器</h3>
            <p>迭代器可以产生无限序列：</p>
            
            <div class="warning">
                使用无限迭代器时要注意：
                <ul>
                    <li>必须有终止条件，否则会造成死循环</li>
                    <li>不能用于需要遍历完整序列的操作（如扩展运算符）</li>
                </ul>
            </div>
            
            <h3>4.3 迭代器的复用</h3>
            <p>迭代器通常是一次性的，调用 <code>[Symbol.iterator]()</code> 会创建新的迭代器：</p>
            
            <h2>五、迭代器与生成器</h2>
            
            <h3>5.1 生成器是迭代器的语法糖</h3>
            <p>生成器函数返回的生成器对象同时实现了迭代器协议和可迭代协议。</p>
            
            <h3>5.2 生成器的优势</h3>
            <ul>
                <li><strong>简洁</strong>：不需要手动维护状态</li>
                <li><strong>惰性</strong>：按需计算，节省内存</li>
                <li><strong>组合</strong>：可以通过 yield* 组合其他迭代器</li>
            </ul>
            
            <h2>六、迭代器模式的应用</h2>
            
            <h3>6.1 惰性求值</h3>
            <p>迭代器允许延迟计算，只在需要时产生值：</p>
            
            <h3>6.2 数据流处理</h3>
            <p>迭代器非常适合处理数据流和管道：</p>
            
            <h3>6.3 自定义遍历逻辑</h3>
            <p>可以为任何数据结构定义自定义的遍历方式：</p>
            
            <h2>七、性能考虑</h2>
            
            <div class="info">
                <strong>性能特点：</strong>
                <ul>
                    <li><strong>内存友好</strong>：惰性求值，不需要一次性生成所有值</li>
                    <li><strong>调用开销</strong>：每次调用 next() 有函数调用开销</li>
                    <li><strong>引擎优化</strong>：现代引擎对迭代器有专门优化</li>
                </ul>
            </div>
            
            <h2>八、规范细节</h2>
            
            <div class="spec">
                <strong>ECMAScript 迭代器相关规范章节：</strong>
                <ul>
                    <li><strong>25.1</strong> - Iteration</li>
                    <li><strong>25.1.1</strong> - Common Iteration Interfaces</li>
                    <li><strong>25.1.2</strong> - The %IteratorPrototype% Object</li>
                    <li><strong>7.4.1</strong> - GetIterator ( obj [ , hint [ , method ] ] )</li>
                    <li><strong>7.4.2</strong> - IteratorNext ( iteratorRecord [ , value ] )</li>
                    <li><strong>7.4.3</strong> - IteratorComplete ( iterResult )</li>
                    <li><strong>7.4.4</strong> - IteratorValue ( iterResult )</li>
                    <li><strong>7.4.5</strong> - IteratorStep ( iteratorRecord )</li>
                    <li><strong>7.4.6</strong> - IteratorClose ( iteratorRecord, completion )</li>
                </ul>
            </div>
            
            <h2>九、最佳实践</h2>
            
            <div class="tip">
                <ul>
                    <li><strong>优先使用生成器</strong>：除非需要精细控制，否则用生成器</li>
                    <li><strong>实现 return() 方法</strong>：确保资源能被正确清理</li>
                    <li><strong>考虑无限序列</strong>：利用惰性求值处理大数据</li>
                    <li><strong>组合迭代器</strong>：通过 yield* 复用现有迭代器</li>
                    <li><strong>注意性能</strong>：对于简单场景，传统循环可能更快</li>
                </ul>
            </div>
            
            <h2>参考资料</h2>
            <ul>
                <li><a href="https://tc39.es/ecma262/#sec-iteration" target="_blank">ECMAScript - Iteration</a></li>
                <li><a href="https://tc39.es/ecma262/#sec-iterator-interface" target="_blank">ECMAScript - Iterator Interface</a></li>
                <li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Iteration_protocols" target="_blank">MDN - 迭代协议</a></li>
                <li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol/iterator" target="_blank">MDN - Symbol.iterator</a></li>
            </ul>
            
            <div class="nav-links">
                <a href="../index.html" class="nav-link home">返回首页</a>
                <a href="17-iterable-protocol.html" class="nav-link next">下一节：可迭代协议</a>
            </div>
        </div>
        
        <div class="code-panel">
            <h2 style="color: #60a5fa; margin-bottom: 1.5rem;">💻 交互式代码示例</h2>
            
            <!-- 示例1: 基本迭代器 -->
            <div class="code-example">
                <h3>示例 1：手动实现迭代器</h3>
                <div class="code-block">
                    <pre><code>// 创建一个简单的范围迭代器
function createRangeIterator(start, end) {
    let current = start;
    
    return {
        next() {
            if (current <= end) {
                return { value: current++, done: false };
            } else {
                return { value: undefined, done: true };
            }
        }
    };
}

const iter = createRangeIterator(1, 5);

console.log(iter.next());  // { value: 1, done: false }
console.log(iter.next());  // { value: 2, done: false }
console.log(iter.next());  // { value: 3, done: false }
console.log(iter.next());  // { value: 4, done: false }
console.log(iter.next());  // { value: 5, done: false }
console.log(iter.next());  // { value: undefined, done: true }</code></pre>
                </div>
                <button class="run-btn">▶ 运行代码</button>
                <div class="output"></div>
            </div>
            
            <!-- 示例2: 可迭代对象 -->
            <div class="code-example">
                <h3>示例 2：实现可迭代对象</h3>
                <div class="code-block">
                    <pre><code>// 创建可迭代的范围对象
const range = {
    start: 1,
    end: 5,
    
    [Symbol.iterator]() {
        let current = this.start;
        const end = this.end;
        
        return {
            next() {
                if (current <= end) {
                    return { value: current++, done: false };
                }
                return { done: true };
            }
        };
    }
};

// 使用 for...of 遍历
console.log('使用 for...of:');
for (const num of range) {
    console.log(num);
}

// 使用扩展运算符
console.log('使用扩展运算符:', [...range]);

// 使用 Array.from
console.log('使用 Array.from:', Array.from(range));</code></pre>
                </div>
                <button class="run-btn">▶ 运行代码</button>
                <div class="output"></div>
            </div>
            
            <!-- 示例3: 实现 return 方法 -->
            <div class="code-example">
                <h3>示例 3：实现 return() 方法</h3>
                <div class="code-block">
                    <pre><code>function createCleanupIterator() {
    let current = 0;
    
    return {
        next() {
            if (current < 5) {
                return { value: current++, done: false };
            }
            return { done: true };
        },
        
        return(value) {
            console.log('✨ 迭代器被提前终止，执行清理');
            return { value, done: true };
        }
    };
}

const iter = createCleanupIterator();

// 提前终止
for (const val of { [Symbol.iterator]: () => iter }) {
    console.log('值:', val);
    if (val === 2) {
        break;  // 触发 return() 方法
    }
}</code></pre>
                </div>
                <button class="run-btn">▶ 运行代码</button>
                <div class="output"></div>
            </div>
            
            <!-- 示例4: 无限迭代器 -->
            <div class="code-example">
                <h3>示例 4：无限迭代器</h3>
                <div class="code-block">
                    <pre><code>// 斐波那契数列迭代器
function* fibonacci() {
    let [a, b] = [0, 1];
    while (true) {
        yield a;
        [a, b] = [b, a + b];
    }
}

const fib = fibonacci();

console.log('前 10 个斐波那契数:');
for (let i = 0; i < 10; i++) {
    console.log(fib.next().value);
}

// 使用手动实现
function createFibonacci() {
    let a = 0, b = 1;
    
    return {
        next() {
            const value = a;
            [a, b] = [b, a + b];
            return { value, done: false };  // 永不完成
        }
    };
}

const fib2 = createFibonacci();
console.log('\n手动实现:');
for (let i = 0; i < 5; i++) {
    console.log(fib2.next().value);
}</code></pre>
                </div>
                <button class="run-btn">▶ 运行代码</button>
                <div class="output"></div>
            </div>
            
            <!-- 示例5: 链式迭代器 -->
            <div class="code-example">
                <h3>示例 5：组合和链式操作</h3>
                <div class="code-block">
                    <pre><code>// 创建可链式操作的迭代器工具
class IterableWrapper {
    constructor(iterable) {
        this.iterable = iterable;
    }
    
    *map(fn) {
        for (const item of this.iterable) {
            yield fn(item);
        }
    }
    
    *filter(predicate) {
        for (const item of this.iterable) {
            if (predicate(item)) {
                yield item;
            }
        }
    }
    
    *take(n) {
        let count = 0;
        for (const item of this.iterable) {
            if (count++ >= n) break;
            yield item;
        }
    }
    
    toArray() {
        return [...this.iterable];
    }
}

// 使用
const numbers = new IterableWrapper([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);

const result = new IterableWrapper(
    new IterableWrapper(numbers.filter(x => x % 2 === 0))
        .map(x => x * 2)
).take(3).toArray();

console.log('结果:', result);  // [4, 8, 12]</code></pre>
                </div>
                <button class="run-btn">▶ 运行代码</button>
                <div class="output"></div>
            </div>
            
            <!-- 示例6: 自定义数据结构 -->
            <div class="code-example">
                <h3>示例 6：二叉树的迭代器</h3>
                <div class="code-block">
                    <pre><code>class TreeNode {
    constructor(value, left = null, right = null) {
        this.value = value;
        this.left = left;
        this.right = right;
    }
    
    // 中序遍历迭代器
    *[Symbol.iterator]() {
        if (this.left) {
            yield* this.left;
        }
        yield this.value;
        if (this.right) {
            yield* this.right;
        }
    }
}

// 构建树:     4
//           /   \
//          2     6
//         / \   / \
//        1   3 5   7
const tree = new TreeNode(
    4,
    new TreeNode(2, new TreeNode(1), new TreeNode(3)),
    new TreeNode(6, new TreeNode(5), new TreeNode(7))
);

console.log('中序遍历:', [...tree]);  // [1, 2, 3, 4, 5, 6, 7]

console.log('使用 for...of:');
for (const val of tree) {
    console.log(val);
}</code></pre>
                </div>
                <button class="run-btn">▶ 运行代码</button>
                <div class="output"></div>
            </div>
        </div>
    </div>
    
    <script src="../assets/js/common.js"></script>
</body>
</html>
