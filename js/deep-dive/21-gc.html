<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>垃圾回收算法 - JavaScript 深度学习</title>
    <link rel="stylesheet" href="../assets/css/main.css">
    <link rel="stylesheet" href="../assets/css/page.css">
</head>
<body>
    <div class="page-layout">
        <div class="doc-panel">
            <h1>垃圾回收算法</h1>
            
            <h2>概述</h2>
            <p>垃圾回收（Garbage Collection, GC）是 JavaScript 自动内存管理的核心机制。了解垃圾回收算法有助于编写高性能代码和避免内存泄漏。</p>
            
            <h2>一、引用计数（Reference Counting）</h2>
            
            <h3>1.1 基本原理</h3>
            <pre><code>// 引用计数：记录每个对象被引用的次数
// 当引用计数为 0 时，对象可以被回收

let obj = { x: 1 };    // obj 的引用计数 = 1

let obj2 = obj;        // obj 的引用计数 = 2

obj = null;            // obj 的引用计数 = 1
obj2 = null;           // obj 的引用计数 = 0，可以回收</code></pre>
            
            <h3>1.2 优点和缺点</h3>
            <div class="info">
                <p><strong>优点</strong>：</p>
                <ul>
                    <li>实现简单</li>
                    <li>回收及时（引用计数为0立即回收）</li>
                </ul>
                
                <p><strong>缺点</strong>：</p>
                <ul>
                    <li>无法处理循环引用</li>
                    <li>频繁更新引用计数影响性能</li>
                </ul>
            </div>
            
            <h3>1.3 循环引用问题</h3>
            <pre><code>// 循环引用导致内存泄漏
function problem() {
    let obj1 = {};
    let obj2 = {};
    
    obj1.ref = obj2;  // obj1 引用 obj2
    obj2.ref = obj1;  // obj2 引用 obj1
    
    // 函数结束后，obj1 和 obj2 的引用计数都不为 0
    // 在纯引用计数算法中无法回收
}

// 现代 JavaScript 引擎使用标记清除，可以处理循环引用</code></pre>
            
            <h2>二、标记清除（Mark-Sweep）</h2>
            
            <h3>2.1 基本原理</h3>
            <pre><code>// 标记清除分两个阶段：

// 1. 标记阶段（Mark）
// - 从根对象开始遍历（全局对象、活动函数栈等）
// - 标记所有可达的对象

// 2. 清除阶段（Sweep）
// - 遍历堆中所有对象
// - 回收未被标记的对象

// 示例：
let obj1 = { x: 1 };     // 可达（被 obj1 引用）
let obj2 = { y: 2 };     // 可达（被 obj2 引用）

obj1 = null;             // obj1 指向的对象变为不可达
// 在下次 GC 时被回收</code></pre>
            
            <h3>2.2 根对象</h3>
            <pre><code>// GC 的根对象包括：

// 1. 全局对象
window.globalVar = { data: 'global' };  // 可达

// 2. 活动函数的局部变量
function active() {
    let local = { data: 'local' };      // 可达
}

// 3. 活动函数的参数
function fn(param) {                     // param 可达
    // ...
}

// 4. 当前执行上下文的闭包变量
function outer() {
    let closure = { data: 'closure' };
    return function() {
        console.log(closure);            // closure 可达
    };
}</code></pre>
            
            <h3>2.3 优缺点</h3>
            <div class="info">
                <p><strong>优点</strong>：</p>
                <ul>
                    <li>可以处理循环引用</li>
                    <li>实现相对简单</li>
                </ul>
                
                <p><strong>缺点</strong>：</p>
                <ul>
                    <li>GC 期间需要暂停程序（Stop-The-World）</li>
                    <li>会产生内存碎片</li>
                    <li>大堆时标记和清除时间长</li>
                </ul>
            </div>
            
            <h2>三、标记整理（Mark-Compact）</h2>
            
            <h3>3.1 基本原理</h3>
            <pre><code>// 标记整理 = 标记清除 + 内存整理

// 阶段：
// 1. 标记：标记所有可达对象
// 2. 整理：将存活对象移动到内存的一端
// 3. 清除：清理边界外的内存

// 优点：解决内存碎片问题
// 缺点：移动对象需要更新所有引用，开销大

// 内存布局示例：
// 标记前：[A][ ][B][C][ ][ ][D]
// 标记后：[A*][ ][B*][C*][ ][ ][D*]
// 整理后：[A][B][C][D][ ][ ][ ]</code></pre>
            
            <h2>四、分代回收（Generational GC）</h2>
            
            <h3>4.1 代际假说</h3>
            <div class="info">
                <p><strong>两个假说</strong>：</p>
                <ul>
                    <li><strong>大部分对象很快死亡</strong>：临时变量、函数调用等</li>
                    <li><strong>存活时间长的对象很少死亡</strong>：全局对象、长期缓存等</li>
                </ul>
            </div>
            
            <h3>4.2 V8 的分代策略</h3>
            <pre><code>// V8 将堆分为两代：

// 1. 新生代（New Generation / Young Generation）
// - 存放新创建的对象
// - 空间小（32MB / 16MB）
// - 使用 Scavenge 算法（复制算法）
// - 回收频繁，速度快

// 2. 老生代（Old Generation）
// - 存放存活时间长的对象
// - 空间大（1.4GB / 700MB）
// - 使用标记清除 + 标记整理
// - 回收较慢，频率低

// 对象晋升：
// 新生代对象经过两次 GC 仍存活 → 晋升到老生代
// 或新生代空间不足时提前晋升</code></pre>
            
            <h3>4.3 Scavenge 算法</h3>
            <pre><code>// 新生代使用 Scavenge（复制算法）

// 新生代分为两个空间：
// - From 空间：存放活动对象
// - To 空间：空闲

// GC 过程：
// 1. 从 From 空间复制存活对象到 To 空间
// 2. 清空 From 空间
// 3. From 和 To 空间角色互换

// 优点：
// - 速度快（只处理存活对象）
// - 没有碎片（紧凑排列）

// 缺点：
// - 只能使用一半空间
// - 需要复制对象

// 内存布局：
// Before GC:
// From: [A][B][ ][C]
// To:   [ ][ ][ ][ ]
// 
// After GC:
// From: [ ][ ][ ][ ]  （清空）
// To:   [A][B][C][ ]  （存活对象）</code></pre>
            
            <h2>五、增量标记（Incremental Marking）</h2>
            
            <h3>5.1 解决 STW 问题</h3>
            <pre><code>// Stop-The-World（STW）：GC 期间程序暂停
// 对于大堆，STW 时间可能很长，影响用户体验

// 增量标记：将标记工作分成小块
// 程序执行 → 标记一部分 → 程序执行 → 标记一部分 → ...

// 优点：
// - 减少单次暂停时间
// - 提高响应性

// 缺点：
// - 总 GC 时间可能增加
// - 需要写屏障（Write Barrier）追踪修改

// 时间线：
// ████ 程序执行
// ░░░░ GC 工作
// 
// 传统 GC：
// ████████░░░░░░░░████████
// 
// 增量 GC：
// ████░░████░░████░░████░░</code></pre>
            
            <h3>5.2 三色标记</h3>
            <pre><code>// 增量标记使用三色标记算法

// 白色：未访问的对象（默认）
// 灰色：已访问但未遍历其引用的对象
// 黑色：已访问且已遍历其引用的对象

// 标记过程：
// 1. 初始：所有对象为白色
// 2. 将根对象标记为灰色
// 3. 从灰色对象开始：
//    - 遍历其引用的对象，标记为灰色
//    - 自身标记为黑色
// 4. 重复直到没有灰色对象
// 5. 清除所有白色对象

// 示例：
// Root → A → B
//        ↓
//        C
// 
// 步骤：
// 1. 白色：A, B, C    灰色：Root  黑色：-
// 2. 白色：B, C       灰色：A     黑色：Root
// 3. 白色：C          灰色：B     黑色：Root, A
// 4. 白色：-          灰色：C     黑色：Root, A, B
// 5. 白色：-          灰色：-     黑色：Root, A, B, C</code></pre>
            
            <h2>六、并发标记（Concurrent Marking）</h2>
            
            <h3>6.1 Orinoco 垃圾回收器</h3>
            <pre><code>// V8 的 Orinoco：并发、并行、增量的 GC

// 1. 并发（Concurrent）
// - GC 线程与主线程同时运行
// - 主线程继续执行 JavaScript
// - 标记和清除可以并发进行

// 2. 并行（Parallel）
// - 多个 GC 线程同时工作
// - 加速 GC 过程

// 3. 增量（Incremental）
// - 分批次执行
// - 减少暂停时间

// 效果：
// - 主要 GC 工作在后台完成
// - 主线程暂停时间显著减少（< 10ms）</code></pre>
            
            <h2>七、写屏障（Write Barrier）</h2>
            
            <h3>7.1 解决并发问题</h3>
            <pre><code>// 并发 GC 的问题：
// GC 标记期间，程序可能修改对象引用

// 示例问题：
// 1. 黑色对象 A 引用白色对象 C
// 2. GC 认为 A 已完成，不会再访问
// 3. C 会被错误回收

// 解决：写屏障
// 每次写入对象引用时，记录修改
// GC 会重新检查这些修改

// 伪代码：
function writeBarrier(object, field, value) {
    // 记录修改
    if (isMarking && isBlack(object) && isWhite(value)) {
        markGrey(value);  // 重新标记为灰色
    }
    
    // 执行写入
    object[field] = value;
}</code></pre>
            
            <h2>八、GC 触发时机</h2>
            
            <h3>8.1 自动触发</h3>
            <pre><code>// GC 自动触发的情况：

// 1. 内存分配失败
// - 新生代空间不足
// - 老生代空间不足

// 2. 定期触发
// - V8 会定期检查内存使用

// 3. 空闲时间
// - requestIdleCallback 期间
// - 浏览器空闲时执行 GC

// 示例：监听内存压力
if (performance.memory) {
    const { usedJSHeapSize, totalJSHeapSize } = performance.memory;
    const usage = usedJSHeapSize / totalJSHeapSize;
    
    if (usage > 0.9) {
        console.log('内存使用率高，可能触发 GC');
    }
}</code></pre>
            
            <h3>8.2 手动触发</h3>
            <pre><code>// Node.js 中可以手动触发 GC
// 需要 --expose-gc 参数运行

// node --expose-gc app.js

if (global.gc) {
    console.log('触发 GC 前:', process.memoryUsage().heapUsed);
    global.gc();
    console.log('触发 GC 后:', process.memoryUsage().heapUsed);
}

// 注意：通常不需要手动触发
// V8 的自动 GC 已经很智能</code></pre>
            
            <h2>九、性能优化</h2>
            
            <h3>9.1 减少 GC 压力</h3>
            <pre><code>// 1. 对象池（Object Pool）
class ObjectPool {
    constructor(factory, size = 100) {
        this.factory = factory;
        this.pool = [];
        
        for (let i = 0; i < size; i++) {
            this.pool.push(factory());
        }
    }
    
    acquire() {
        return this.pool.pop() || this.factory();
    }
    
    release(obj) {
        this.pool.push(obj);
    }
}

// 使用
const pool = new ObjectPool(() => ({ x: 0, y: 0 }));

function process() {
    const point = pool.acquire();
    // 使用 point
    point.x = 10;
    point.y = 20;
    // 归还
    pool.release(point);
}

// 2. 避免临时对象
// 不好 ❌
function bad() {
    for (let i = 0; i < 10000; i++) {
        const temp = { x: i };  // 创建 10000 个临时对象
        process(temp);
    }
}

// 好 ✓
function good() {
    const reused = { x: 0 };
    for (let i = 0; i < 10000; i++) {
        reused.x = i;  // 复用对象
        process(reused);
    }
}</code></pre>
            
            <h2>十、最佳实践</h2>
            
            <div class="tip">
                <ol>
                    <li><strong>避免全局变量</strong>：减少老生代对象</li>
                    <li><strong>及时解除引用</strong>：帮助 GC 识别垃圾</li>
                    <li><strong>复用对象</strong>：减少分配和回收</li>
                    <li><strong>避免内存泄漏</strong>：注意闭包、定时器、事件监听器</li>
                    <li><strong>使用 WeakMap/WeakSet</strong>：让 GC 自动清理</li>
                    <li><strong>监控内存</strong>：使用 DevTools 分析</li>
                    <li><strong>信任 GC</strong>：通常不需要手动干预</li>
                </ol>
            </div>
            
            <h2>参考资料</h2>
            <ul>
                <li><a href="https://v8.dev/blog/trash-talk" target="_blank">V8 - Trash talk: the Orinoco garbage collector</a></li>
                <li><a href="https://v8.dev/blog/concurrent-marking" target="_blank">V8 - Concurrent marking</a></li>
            </ul>
            
            <div class="nav-links">
                <a href="21-memory-model.html" class="nav-link prev">上一节：内存模型</a>
                <a href="../index.html" class="nav-link home">返回首页</a>
                <a href="21-memory-leak.html" class="nav-link next">下一节：内存泄漏分析</a>
            </div>
        </div>
        
        <div class="code-panel">
            <h2 style="color: #60a5fa; margin-bottom: 1.5rem;">💻 交互式代码示例</h2>
            
            <div class="code-example">
                <h3>示例 1：循环引用</h3>
                <div class="code-block">
                    <pre><code>// 循环引用与垃圾回收
console.log('=== 循环引用 ===\n');

function createCircular() {
    const obj1 = { name: 'obj1' };
    const obj2 = { name: 'obj2' };
    
    obj1.ref = obj2;
    obj2.ref = obj1;
    
    console.log('创建循环引用:');
    console.log('  obj1 → obj2');
    console.log('  obj2 → obj1');
    
    return { obj1, obj2 };
}

let circular = createCircular();

console.log('\n访问:');
console.log('  circular.obj1.ref.name =', circular.obj1.ref.name);

console.log('\n解除引用:');
circular = null;

console.log('  现代 GC 可以回收循环引用的对象');
console.log('  （标记清除算法）');</code></pre>
                </div>
                <button class="run-btn">▶ 运行代码</button>
                <div class="output"></div>
            </div>
            
            <div class="code-example">
                <h3>示例 2：对象可达性</h3>
                <div class="code-block">
                    <pre><code>// 对象的可达性
console.log('=== 对象可达性 ===\n');

console.log('1. 全局对象（可达）:');
window.globalObj = { data: 'global' };
console.log('  window.globalObj 可达');

console.log('\n2. 局部变量（可达）:');
function test() {
    let local = { data: 'local' };
    console.log('  local 可达（函数执行期间）');
}
test();
console.log('  local 不可达（函数执行后）');

console.log('\n3. 闭包变量（可达）:');
function outer() {
    let closure = { data: 'closure' };
    
    return function() {
        return closure;
    };
}
const fn = outer();
console.log('  closure 可达（被闭包引用）');
console.log('  ' + fn().data);</code></pre>
                </div>
                <button class="run-btn">▶ 运行代码</button>
                <div class="output"></div>
            </div>
            
            <div class="code-example">
                <h3>示例 3：分代回收演示</h3>
                <div class="code-block">
                    <pre><code>// 分代回收概念演示
console.log('=== 分代回收 ===\n');

console.log('1. 新生代对象（短命）:');
function createTemp() {
    const temp = { data: new Array(100).fill(1) };
    console.log('  创建临时对象');
    return temp.data.length;
}

for (let i = 0; i < 3; i++) {
    createTemp();
}
console.log('  这些对象快速死亡，频繁 GC');

console.log('\n2. 老生代对象（长命）:');
const longLived = {
    cache: {},
    add(key, value) {
        this.cache[key] = value;
    }
};

for (let i = 0; i < 3; i++) {
    longLived.add(`key${i}`, i);
}
console.log('  cache 存活时间长');
console.log('  晋升到老生代，较少 GC');

console.log('\n分代策略:');
console.log('  新生代: 小空间，快速 GC');
console.log('  老生代: 大空间，慢速 GC');</code></pre>
                </div>
                <button class="run-btn">▶ 运行代码</button>
                <div class="output"></div>
            </div>
            
            <div class="code-example">
                <h3>示例 4：对象池优化</h3>
                <div class="code-block">
                    <pre><code>// 对象池减少 GC 压力
console.log('=== 对象池 ===\n');

class ObjectPool {
    constructor(factory, size = 10) {
        this.factory = factory;
        this.pool = [];
        
        for (let i = 0; i < size; i++) {
            this.pool.push(factory());
        }
    }
    
    acquire() {
        return this.pool.pop() || this.factory();
    }
    
    release(obj) {
        this.pool.push(obj);
    }
}

const pool = new ObjectPool(() => ({ x: 0, y: 0 }), 5);

console.log('使用对象池:');
for (let i = 0; i < 3; i++) {
    const point = pool.acquire();
    point.x = i;
    point.y = i * 2;
    console.log(`  Point ${i}:`, point);
    pool.release(point);
}

console.log('\n优势:');
console.log('  - 复用对象，减少分配');
console.log('  - 减少 GC 压力');</code></pre>
                </div>
                <button class="run-btn">▶ 运行代码</button>
                <div class="output"></div>
            </div>
            
            <div class="code-example">
                <h3>示例 5：避免临时对象</h3>
                <div class="code-block">
                    <pre><code>// 避免创建临时对象
console.log('=== 避免临时对象 ===\n');

console.log('不好的做法（创建大量临时对象）:');
console.time('temp-objects');
for (let i = 0; i < 1000; i++) {
    const temp = { x: i, y: i * 2 };
    // 使用 temp
}
console.timeEnd('temp-objects');

console.log('\n好的做法（复用对象）:');
console.time('reuse-object');
const reused = { x: 0, y: 0 };
for (let i = 0; i < 1000; i++) {
    reused.x = i;
    reused.y = i * 2;
    // 使用 reused
}
console.timeEnd('reuse-object');

console.log('\n优势:');
console.log('  - 减少内存分配');
console.log('  - 减少 GC 次数');
console.log('  - 提高性能');</code></pre>
                </div>
                <button class="run-btn">▶ 运行代码</button>
                <div class="output"></div>
            </div>
            
            <div class="code-example">
                <h3>示例 6：WeakMap 与 GC</h3>
                <div class="code-block">
                    <pre><code>// WeakMap 不阻止垃圾回收
console.log('=== WeakMap 与 GC ===\n');

console.log('1. Map（强引用）:');
let key1 = { id: 1 };
const map = new Map();
map.set(key1, 'value1');
console.log('  设置 key1');

key1 = null;
console.log('  key1 = null');
console.log('  Map.size:', map.size);
console.log('  对象仍在内存中（不能被 GC）');

console.log('\n2. WeakMap（弱引用）:');
let key2 = { id: 2 };
const weakMap = new WeakMap();
weakMap.set(key2, 'value2');
console.log('  设置 key2');

key2 = null;
console.log('  key2 = null');
console.log('  对象可以被 GC');

console.log('\n用途:');
console.log('  - 缓存');
console.log('  - 私有数据');
console.log('  - DOM 元素关联数据');</code></pre>
                </div>
                <button class="run-btn">▶ 运行代码</button>
                <div class="output"></div>
            </div>
        </div>
    </div>
    
    <script src="../assets/js/common.js"></script>
</body>
</html>
