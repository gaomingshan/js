<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>事件循环规范详解 - JavaScript 深度学习</title>
    <link rel="stylesheet" href="../assets/css/main.css">
    <link rel="stylesheet" href="../assets/css/page.css">
</head>
<body>
    <div class="page-layout">
        <div class="doc-panel">
            <h1>事件循环规范详解</h1>
            
            <h2>概述</h2>
            <p>事件循环（Event Loop）是 JavaScript 运行时的核心机制，它使得 JavaScript 能够在单线程环境中处理异步操作。理解事件循环对于编写高性能的异步代码至关重要。</p>
            
            <div class="spec">
                <strong>HTML 规范定义：</strong>
                事件循环协调事件、用户交互、脚本、渲染、网络等。每个代理（浏览器标签页、Worker等）都有一个独立的事件循环。
            </div>
            
            <h2>一、事件循环的基本概念</h2>
            
            <h3>1.1 调用栈（Call Stack）</h3>
            <p>JavaScript 是单线程的，所有代码都在调用栈中执行：</p>
            
            <ul>
                <li><strong>LIFO 结构</strong>：后进先出</li>
                <li><strong>同步执行</strong>：栈顶函数执行完才能执行下一个</li>
                <li><strong>栈溢出</strong>：递归过深会导致 Stack Overflow</li>
            </ul>
            
            <h3>1.2 任务队列（Task Queue）</h3>
            <p>JavaScript 运行时包含多个任务队列：</p>
            
            <div class="spec">
                <strong>队列类型：</strong>
                <ul>
                    <li><strong>宏任务队列</strong>（Macrotask / Task Queue）</li>
                    <li><strong>微任务队列</strong>（Microtask Queue）</li>
                </ul>
            </div>
            
            <h2>二、宏任务与微任务</h2>
            
            <h3>2.1 宏任务（Macrotask）</h3>
            <p>宏任务是由宿主环境（浏览器/Node.js）发起的任务：</p>
            
            <ul>
                <li><code>script</code>（整体代码）</li>
                <li><code>setTimeout</code></li>
                <li><code>setInterval</code></li>
                <li><code>setImmediate</code>（Node.js）</li>
                <li><code>I/O</code></li>
                <li><code>UI rendering</code>（浏览器）</li>
                <li><code>requestAnimationFrame</code>（浏览器）</li>
            </ul>
            
            <h3>2.2 微任务（Microtask）</h3>
            <p>微任务是由 JavaScript 引擎发起的任务：</p>
            
            <ul>
                <li><code>Promise.then/catch/finally</code></li>
                <li><code>MutationObserver</code>（浏览器）</li>
                <li><code>queueMicrotask()</code></li>
                <li><code>process.nextTick()</code>（Node.js，优先级最高）</li>
            </ul>
            
            <div class="spec">
                <strong>关键差异：</strong>
                <pre>微任务优先级 > 宏任务优先级

每个宏任务执行完毕后，会清空所有微任务队列，
然后才会执行下一个宏任务。</pre>
            </div>
            
            <h2>三、事件循环的执行流程</h2>
            
            <h3>3.1 完整执行流程</h3>
            <div class="spec">
                <strong>标准流程（简化版）：</strong>
                <pre>1. 执行同步代码（调用栈）
   
2. 调用栈清空后，检查微任务队列
   - 执行所有微任务
   - 如果微任务产生新的微任务，继续执行
   - 直到微任务队列为空
   
3. 渲染（如果需要）
   - 浏览器可能会进行 UI 渲染
   
4. 取出一个宏任务执行
   
5. 回到步骤 2，重复循环</pre>
            </div>
            
            <h3>3.2 详细算法（HTML 规范）</h3>
            <div class="spec">
                <strong>事件循环处理模型：</strong>
                <pre>1. 选择最老的任务（来自任务队列）
2. 设置为当前正在运行的任务
3. 运行该任务
4. 设置当前正在运行的任务为 null
5. 从任务队列中移除该任务
6. 执行微任务检查点（Microtask Checkpoint）：
   a. 如果微任务队列不为空
   b. 选择最老的微任务
   c. 设置为当前正在运行的任务
   d. 运行该微任务
   e. 设置当前正在运行的任务为 null
   f. 从微任务队列中移除该微任务
   g. 回到步骤 a
7. 更新渲染（如果需要）
8. 回到步骤 1</pre>
            </div>
            
            <h2>四、关键时序问题</h2>
            
            <h3>4.1 执行顺序示例</h3>
            <pre><code>console.log('1');

setTimeout(() => console.log('2'), 0);

Promise.resolve().then(() => console.log('3'));

console.log('4');

// 输出顺序：1, 4, 3, 2</code></pre>
            
            <h3>4.2 微任务的递归</h3>
            <p>微任务可以无限递归添加微任务，会阻塞渲染：</p>
            
            <div class="warning">
                <strong>危险操作：</strong>
                <pre><code>// 会阻塞主线程！
function recursiveMicrotask() {
    Promise.resolve().then(recursiveMicrotask);
}
recursiveMicrotask();</code></pre>
            </div>
            
            <h3>4.3 宏任务的间隔</h3>
            <p>宏任务之间可以进行渲染，微任务不行：</p>
            
            <h2>五、浏览器与 Node.js 的差异</h2>
            
            <h3>5.1 浏览器事件循环</h3>
            <ul>
                <li>每个标签页有独立的事件循环</li>
                <li>Web Workers 有自己的事件循环</li>
                <li>包含渲染阶段</li>
            </ul>
            
            <h3>5.2 Node.js 事件循环</h3>
            <div class="spec">
                <strong>Node.js 事件循环的 6 个阶段：</strong>
                <pre>┌───────────────────────────┐
│        timers             │ setTimeout/setInterval
├───────────────────────────┤
│     pending callbacks     │ 系统操作的回调
├───────────────────────────┤
│       idle, prepare       │ 内部使用
├───────────────────────────┤
│        poll               │ I/O 回调
├───────────────────────────┤
│        check              │ setImmediate
├───────────────────────────┤
│    close callbacks        │ socket.on('close')
└───────────────────────────┘</pre>
            </div>
            
            <h3>5.3 process.nextTick()</h3>
            <p>Node.js 特有，优先级高于所有微任务：</p>
            
            <pre><code>process.nextTick > Promise.then > setTimeout</code></pre>
            
            <h2>六、性能优化</h2>
            
            <h3>6.1 避免长任务</h3>
            <div class="tip">
                <strong>最佳实践：</strong>
                <ul>
                    <li>将长任务拆分成多个短任务</li>
                    <li>使用 <code>setTimeout(..., 0)</code> 让出主线程</li>
                    <li>使用 Web Workers 处理计算密集型任务</li>
                    <li>使用 <code>requestIdleCallback</code> 执行低优先级任务</li>
                </ul>
            </div>
            
            <h3>6.2 合理使用微任务</h3>
            <ul>
                <li>微任务适合快速的状态更新</li>
                <li>避免在微任务中执行耗时操作</li>
                <li>注意微任务的递归问题</li>
            </ul>
            
            <h3>6.3 requestAnimationFrame</h3>
            <p>用于动画，在浏览器下次重绘前执行：</p>
            
            <pre><code>requestAnimationFrame > 渲染 > setTimeout(..., 0)</code></pre>
            
            <h2>七、调试技巧</h2>
            
            <div class="info">
                <strong>调试工具：</strong>
                <ul>
                    <li><strong>Chrome DevTools</strong>：Performance 面板查看任务执行</li>
                    <li><strong>console.trace()</strong>：追踪调用栈</li>
                    <li><strong>Performance.now()</strong>：测量任务耗时</li>
                    <li><strong>Long Tasks API</strong>：检测长任务</li>
                </ul>
            </div>
            
            <h2>八、常见误区</h2>
            
            <h3>8.1 setTimeout(..., 0) 的误解</h3>
            <div class="warning">
                <code>setTimeout(..., 0)</code> 并不是立即执行，而是在下一个宏任务执行。
            </div>
            
            <h3>8.2 async/await 的本质</h3>
            <p><code>async/await</code> 本质上是 Promise 的语法糖，遵循微任务规则。</p>
            
            <h3>8.3 事件循环不是多线程</h3>
            <p>JavaScript 始终是单线程的，事件循环只是调度机制。</p>
            
            <h2>参考资料</h2>
            <ul>
                <li><a href="https://html.spec.whatwg.org/multipage/webappapis.html#event-loops" target="_blank">HTML - Event Loops</a></li>
                <li><a href="https://tc39.es/ecma262/#sec-jobs" target="_blank">ECMAScript - Jobs and Host Operations</a></li>
                <li><a href="https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/" target="_blank">Node.js - Event Loop</a></li>
                <li><a href="https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/" target="_blank">Jake Archibald - Tasks, microtasks, queues</a></li>
            </ul>
            
            <div class="nav-links">
                <a href="../index.html" class="nav-link home">返回首页</a>
                <a href="19-task-queue.html" class="nav-link next">下一节：宏任务与微任务</a>
            </div>
        </div>
        
        <div class="code-panel">
            <h2 style="color: #60a5fa; margin-bottom: 1.5rem;">💻 交互式代码示例</h2>
            
            <!-- 示例1: 基本执行顺序 -->
            <div class="code-example">
                <h3>示例 1：宏任务与微任务顺序</h3>
                <div class="code-block">
                    <pre><code>console.log('🔵 同步 1');

setTimeout(() => {
    console.log('🔴 宏任务 setTimeout 1');
}, 0);

Promise.resolve()
    .then(() => {
        console.log('🟢 微任务 Promise 1');
    })
    .then(() => {
        console.log('🟢 微任务 Promise 2');
    });

setTimeout(() => {
    console.log('🔴 宏任务 setTimeout 2');
}, 0);

console.log('🔵 同步 2');

// 输出顺序：
// 🔵 同步 1
// 🔵 同步 2
// 🟢 微任务 Promise 1
// 🟢 微任务 Promise 2
// 🔴 宏任务 setTimeout 1
// 🔴 宏任务 setTimeout 2</code></pre>
                </div>
                <button class="run-btn">▶ 运行代码</button>
                <div class="output"></div>
            </div>
            
            <!-- 示例2: 复杂嵌套 -->
            <div class="code-example">
                <h3>示例 2：复杂嵌套情况</h3>
                <div class="code-block">
                    <pre><code>console.log('1');

setTimeout(() => {
    console.log('2');
    Promise.resolve().then(() => {
        console.log('3');
    });
}, 0);

Promise.resolve()
    .then(() => {
        console.log('4');
        setTimeout(() => {
            console.log('5');
        }, 0);
    });

console.log('6');

// 输出：1, 6, 4, 2, 3, 5</code></pre>
                </div>
                <button class="run-btn">▶ 运行代码</button>
                <div class="output"></div>
            </div>
            
            <!-- 示例3: async/await -->
            <div class="code-example">
                <h3>示例 3：async/await 的执行顺序</h3>
                <div class="code-block">
                    <pre><code>console.log('开始');

async function async1() {
    console.log('async1 开始');
    await async2();
    console.log('async1 结束');  // 微任务
}

async function async2() {
    console.log('async2');
}

setTimeout(() => {
    console.log('setTimeout');
}, 0);

async1();

Promise.resolve().then(() => {
    console.log('Promise.then');
});

console.log('结束');

// 输出顺序：
// 开始
// async1 开始
// async2
// 结束
// async1 结束
// Promise.then
// setTimeout</code></pre>
                </div>
                <button class="run-btn">▶ 运行代码</button>
                <div class="output"></div>
            </div>
            
            <!-- 示例4: 拆分长任务 -->
            <div class="code-example">
                <h3>示例 4：拆分长任务</h3>
                <div class="code-block">
                    <pre><code>// 模拟长任务
function longTask() {
    console.log('⏳ 开始长任务');
    let sum = 0;
    for (let i = 0; i < 1000000; i++) {
        sum += i;
    }
    console.log('✅ 长任务完成:', sum);
}

// 拆分长任务
function splitTask(items, chunkSize = 100) {
    let index = 0;
    
    function processChunk() {
        const chunk = items.slice(index, index + chunkSize);
        console.log(`处理第 ${index / chunkSize + 1} 批`);
        
        // 处理这一批数据
        chunk.forEach(item => {
            // 处理逻辑
        });
        
        index += chunkSize;
        
        if (index < items.length) {
            // 让出主线程，下一个宏任务继续
            setTimeout(processChunk, 0);
        } else {
            console.log('✅ 所有任务完成');
        }
    }
    
    processChunk();
}

// 测试
const data = Array.from({ length: 300 }, (_, i) => i);
splitTask(data, 100);</code></pre>
                </div>
                <button class="run-btn">▶ 运行代码</button>
                <div class="output"></div>
            </div>
            
            <!-- 示例5: 微任务递归 -->
            <div class="code-example">
                <h3>示例 5：微任务递归（小心使用）</h3>
                <div class="code-block">
                    <pre><code>let count = 0;
const maxCount = 5;

function recursiveMicrotask() {
    if (count < maxCount) {
        count++;
        console.log(`微任务 ${count}`);
        Promise.resolve().then(recursiveMicrotask);
    } else {
        console.log('✅ 微任务递归完成');
    }
}

console.log('开始');

setTimeout(() => {
    console.log('宏任务 - setTimeout');
}, 0);

recursiveMicrotask();

console.log('结束');

// 注意：所有微任务会在宏任务之前完成</code></pre>
                </div>
                <button class="run-btn">▶ 运行代码</button>
                <div class="output"></div>
            </div>
            
            <!-- 示例6: queueMicrotask -->
            <div class="code-example">
                <h3>示例 6：queueMicrotask API</h3>
                <div class="code-block">
                    <pre><code>console.log('1');

queueMicrotask(() => {
    console.log('2 - queueMicrotask');
});

Promise.resolve().then(() => {
    console.log('3 - Promise.then');
});

queueMicrotask(() => {
    console.log('4 - queueMicrotask');
});

console.log('5');

// queueMicrotask 和 Promise.then 都是微任务
// 执行顺序：1, 5, 2, 3, 4
// (按照添加到微任务队列的顺序)</code></pre>
                </div>
                <button class="run-btn">▶ 运行代码</button>
                <div class="output"></div>
            </div>
        </div>
    </div>
    
    <script src="../assets/js/common.js"></script>
</body>
</html>
