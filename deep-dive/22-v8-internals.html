<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>V8 内部机制 - JavaScript 深度学习</title>
    <link rel="stylesheet" href="../assets/css/main.css">
    <link rel="stylesheet" href="../assets/css/page.css">
</head>
<body>
    <div class="page-layout">
        <div class="doc-panel">
            <h1>V8 内部机制</h1>
            
            <h2>概述</h2>
            <p>V8 是 Google 开发的高性能 JavaScript 引擎，用于 Chrome 和 Node.js。理解 V8 的内部机制有助于编写更高效的 JavaScript 代码。</p>
            
            <h2>一、V8 架构</h2>
            
            <h3>1.1 主要组件</h3>
            <div class="info">
                <ul>
                    <li><strong>解析器（Parser）</strong>：将 JavaScript 源码转换为 AST</li>
                    <li><strong>解释器（Ignition）</strong>：将 AST 转换为字节码并执行</li>
                    <li><strong>优化编译器（TurboFan）</strong>：将热点代码编译为优化的机器码</li>
                    <li><strong>垃圾回收器（Orinoco）</strong>：管理内存回收</li>
                </ul>
            </div>
            
            <h3>1.2 执行流程</h3>
            <pre><code>// V8 执行 JavaScript 的流程

源代码
  ↓
解析器（Parser）
  ↓
抽象语法树（AST）
  ↓
解释器（Ignition）
  ↓
字节码（Bytecode）
  ↓ （热点代码）
优化编译器（TurboFan）
  ↓
优化的机器码（Optimized Machine Code）</code></pre>
            
            <h2>二、Ignition 解释器</h2>
            
            <h3>2.1 字节码</h3>
            <pre><code>// JavaScript 源码
function add(a, b) {
    return a + b;
}

// 对应的字节码（简化）
// LdaNamedProperty a  // 加载 a
// Star r0             // 存储到寄存器 r0
// LdaNamedProperty b  // 加载 b
// Add r0              // r0 + b
// Return              // 返回结果

// 优点：
// - 比解释 AST 快
// - 比机器码占用空间小
// - 启动速度快</code></pre>
            
            <h3>2.2 字节码优势</h3>
            <div class="info">
                <p><strong>为什么使用字节码</strong>：</p>
                <ul>
                    <li>减少内存占用（比机器码小）</li>
                    <li>加快启动速度（不需要完全编译）</li>
                    <li>简化编译流程</li>
                    <li>便于收集类型反馈</li>
                </ul>
            </div>
            
            <h2>三、TurboFan 优化编译器</h2>
            
            <h3>3.1 热点检测</h3>
            <pre><code>// V8 跟踪函数和循环的执行次数
function hotFunction() {
    // 函数被多次调用后：
    // 1. Ignition 执行字节码
    // 2. 收集类型反馈
    // 3. 达到阈值后，TurboFan 开始优化
    // 4. 生成优化的机器码
}

// 热点阈值（大约）：
// - 函数调用 ~1000 次
// - 循环迭代 ~10000 次</code></pre>
            
            <h3>3.2 优化示例</h3>
            <pre><code>// 示例 1：类型特化
function add(a, b) {
    return a + b;
}

// 如果始终用数字调用
add(1, 2);
add(3, 4);
add(5, 6);
// TurboFan 优化为：直接的数字加法指令

// 如果后来用字符串调用
add('hello', 'world');
// 触发去优化（Deoptimization）

// 示例 2：内联
function square(x) {
    return x * x;
}

function sumOfSquares(a, b) {
    return square(a) + square(b);
}

// 优化后，square 可能被内联到 sumOfSquares 中
// 减少函数调用开销</code></pre>
            
            <h3>3.3 去优化（Deoptimization）</h3>
            <pre><code>// 当优化的假设被打破时，触发去优化
function process(obj) {
    return obj.x + obj.y;
}

// 假设 obj 总是 { x: number, y: number }
process({ x: 1, y: 2 });
process({ x: 3, y: 4 });
// TurboFan 优化

// 但如果结构改变
process({ x: 1, y: 2, z: 3 });  // 可能触发去优化

// 或类型改变
process({ x: 'a', y: 'b' });    // 触发去优化

// 去优化代价高昂，应避免</code></pre>
            
            <h2>四、隐藏类（Hidden Classes）</h2>
            
            <h3>4.1 概念</h3>
            <pre><code>// JavaScript 对象是动态的，但 V8 使用隐藏类优化

// 相同结构的对象共享隐藏类
const obj1 = { x: 1, y: 2 };
const obj2 = { x: 3, y: 4 };
// obj1 和 obj2 共享同一个隐藏类

// 不同结构的对象有不同隐藏类
const obj3 = { x: 1 };      // 隐藏类 A
const obj4 = { x: 1, y: 2 }; // 隐藏类 B（不同）

// 隐藏类转换
const obj5 = {};
// 隐藏类 C0
obj5.x = 1;
// 转换到隐藏类 C1（有属性 x）
obj5.y = 2;
// 转换到隐藏类 C2（有属性 x, y）</code></pre>
            
            <h3>4.2 优化技巧</h3>
            <pre><code>// 好的做法 ✓
// 1. 相同顺序初始化
function Point(x, y) {
    this.x = x;  // 始终先 x
    this.y = y;  // 然后 y
}

// 2. 避免动态添加属性
const obj = { x: 1, y: 2, z: 3 };  // 一次性定义

// 3. 使用构造函数或类
class Rectangle {
    constructor(width, height) {
        this.width = width;
        this.height = height;
    }
}

// 不好的做法 ❌
// 1. 不同顺序初始化
const obj1 = {};
obj1.x = 1;
obj1.y = 2;

const obj2 = {};
obj2.y = 2;  // 顺序不同！
obj2.x = 1;

// 2. 删除属性
delete obj.x;  // 触发隐藏类转换，性能差

// 3. 动态添加属性
obj.newProp = 3;  // 隐藏类转换</code></pre>
            
            <h2>五、内联缓存（Inline Caching）</h2>
            
            <h3>5.1 工作原理</h3>
            <pre><code>// V8 缓存属性访问的位置

function getX(obj) {
    return obj.x;
}

// 第一次调用
getX({ x: 1 });
// V8 记录：x 在偏移量 0

// 第二次调用（相同结构）
getX({ x: 2 });
// 直接从偏移量 0 读取（快！）

// 不同结构
getX({ y: 1, x: 2 });
// x 在不同位置，缓存失效</code></pre>
            
            <h3>5.2 单态、多态、超态</h3>
            <pre><code>// 单态（Monomorphic）：一种类型
function process(obj) {
    return obj.x;
}

process({ x: 1, y: 2 });
process({ x: 3, y: 4 });
// 始终是相同结构，单态，最快

// 多态（Polymorphic）：少数几种类型（2-4种）
process({ x: 1 });
process({ x: 2, y: 3 });
process({ x: 4, y: 5, z: 6 });
// 多种结构，多态，较快

// 超态（Megamorphic）：很多种类型（>4种）
process({ a: 1 });
process({ b: 2 });
process({ c: 3 });
process({ d: 4 });
process({ e: 5 });
// 太多结构，超态，慢

// 优化建议：保持对象结构一致</code></pre>
            
            <h2>六、数组优化</h2>
            
            <h3>6.1 数组元素类型</h3>
            <pre><code>// V8 对数组有特殊优化

// 1. SMI 数组（Small Integer）
const arr1 = [1, 2, 3, 4, 5];
// 最快，元素是小整数

// 2. Double 数组
const arr2 = [1.1, 2.2, 3.3];
// 较快，元素是浮点数

// 3. 对象数组
const arr3 = [{ x: 1 }, { x: 2 }];
// 较慢，元素是对象引用

// 4. 混合数组
const arr4 = [1, 'string', { x: 1 }];
// 最慢，元素类型不一致

// 类型转换（不可逆）
const arr = [1, 2, 3];      // SMI
arr.push(1.1);              // 转换为 Double
arr.push('string');         // 转换为混合（不能再优化）</code></pre>
            
            <h3>6.2 稀疏数组</h3>
            <pre><code>// 密集数组 vs 稀疏数组

// 密集数组（快）
const dense = [1, 2, 3, 4, 5];
// 连续内存

// 稀疏数组（慢）
const sparse = [];
sparse[0] = 1;
sparse[1000] = 2;
// 哈希表存储

// 避免创建稀疏数组
// ❌ 不好
const arr = [];
arr[100] = 1;

// ✓ 好
const arr = new Array(101).fill(0);
arr[100] = 1;</code></pre>
            
            <h2>七、性能优化建议</h2>
            
            <h3>7.1 对象优化</h3>
            <pre><code>// 1. 使用构造函数或类
class Point {
    constructor(x, y) {
        this.x = x;
        this.y = y;
    }
}

// 2. 避免动态属性
// ❌
obj.newProp = 1;

// ✓
const obj = { newProp: 1 };

// 3. 避免删除属性
// ❌
delete obj.prop;

// ✓
obj.prop = undefined;  // 或 null

// 4. 相同顺序初始化
function create1() {
    return { x: 1, y: 2 };
}

function create2() {
    return { x: 3, y: 4 };  // 相同顺序
}</code></pre>
            
            <h3>7.2 函数优化</h3>
            <pre><code>// 1. 避免频繁改变参数类型
function add(a, b) {
    return a + b;
}

// ✓ 好
add(1, 2);
add(3, 4);

// ❌ 不好
add(1, 2);
add('a', 'b');  // 类型改变，去优化

// 2. 使用单态函数
function process(obj) {
    return obj.x;
}

// ✓ 好：始终相同结构
process({ x: 1, y: 2 });
process({ x: 3, y: 4 });

// 3. 小函数易内联
function small(x) {
    return x * 2;  // 小函数，易被内联
}

// 4. 避免 try-catch 在热路径
// try-catch 会阻止某些优化</code></pre>
            
            <h3>7.3 数组优化</h3>
            <pre><code>// 1. 保持元素类型一致
const numbers = [1, 2, 3, 4, 5];  // ✓ 全是数字

// 2. 避免稀疏数组
const arr = new Array(100).fill(0);  // ✓ 密集

// 3. 预分配大小
const arr = new Array(1000);  // 如果知道大小

// 4. 使用 TypedArray
const uint32 = new Uint32Array(1000);  // 性能最好</code></pre>
            
            <h2>八、调试和分析</h2>
            
            <h3>8.1 V8 标志</h3>
            <pre><code>// Node.js 中使用 V8 标志

// 查看优化状态
// node --trace-opt script.js
// 显示哪些函数被优化

// 查看去优化
// node --trace-deopt script.js
// 显示哪些函数被去优化

// 查看内联缓存
// node --trace-ic script.js
// 显示 IC 状态（单态、多态等）

// 打印字节码
// node --print-bytecode script.js
// 查看生成的字节码</code></pre>
            
            <h3>8.2 性能分析</h3>
            <pre><code>// 使用 Chrome DevTools

// 1. Performance 面板
// - 记录性能
// - 查看函数调用
// - 找出热点

// 2. Memory 面板
// - 堆快照
// - 内存分配

// 3. 使用 console.time
console.time('operation');
// ... 代码
console.timeEnd('operation');</code></pre>
            
            <h2>九、最佳实践</h2>
            
            <div class="tip">
                <ol>
                    <li><strong>保持对象结构一致</strong>：利用隐藏类优化</li>
                    <li><strong>避免类型混用</strong>：保持函数参数类型稳定</li>
                    <li><strong>使用类和构造函数</strong>：更好的优化</li>
                    <li><strong>避免删除属性</strong>：设为 null/undefined</li>
                    <li><strong>数组类型一致</strong>：避免混合类型数组</li>
                    <li><strong>预热函数</strong>：重要函数多次调用让 V8 优化</li>
                    <li><strong>测量性能</strong>：使用工具验证优化效果</li>
                </ol>
            </div>
            
            <h2>参考资料</h2>
            <ul>
                <li><a href="https://v8.dev/blog" target="_blank">V8 官方博客</a></li>
                <li><a href="https://mathiasbynens.be/notes/shapes-ics" target="_blank">JavaScript engine fundamentals: Shapes and Inline Caches</a></li>
            </ul>
            
            <div class="nav-links">
                <a href="21-memory-leak.html" class="nav-link prev">上一节：内存泄漏分析</a>
                <a href="../index.html" class="nav-link home">返回首页</a>
                <a href="22-jit.html" class="nav-link next">下一节：JIT 编译优化</a>
            </div>
        </div>
        
        <div class="code-panel">
            <h2 style="color: #60a5fa; margin-bottom: 1.5rem;">💻 交互式代码示例</h2>
            
            <div class="code-example">
                <h3>示例 1：隐藏类</h3>
                <div class="code-block">
                    <pre><code>// 隐藏类演示
console.log('=== 隐藏类 ===\n');

console.log('1. 相同结构（共享隐藏类）:');
function Point(x, y) {
    this.x = x;
    this.y = y;
}

const p1 = new Point(1, 2);
const p2 = new Point(3, 4);
console.log('  p1 和 p2 共享隐藏类');

console.log('\n2. 不同顺序（不同隐藏类）:');
const obj1 = {};
obj1.x = 1;
obj1.y = 2;

const obj2 = {};
obj2.y = 2;  // 顺序不同
obj2.x = 1;
console.log('  obj1 和 obj2 有不同隐藏类');

console.log('\n优化建议:');
console.log('  ✓ 使用构造函数/类');
console.log('  ✓ 相同顺序初始化');</code></pre>
                </div>
                <button class="run-btn">▶ 运行代码</button>
                <div class="output"></div>
            </div>
            
            <div class="code-example">
                <h3>示例 2：单态 vs 多态</h3>
                <div class="code-block">
                    <pre><code>// 单态和多态性能对比
console.log('=== 单态 vs 多态 ===\n');

function getX(obj) {
    return obj.x;
}

console.log('1. 单态（最快）:');
console.time('monomorphic');
for (let i = 0; i < 100000; i++) {
    getX({ x: 1, y: 2 });
    getX({ x: 3, y: 4 });
}
console.timeEnd('monomorphic');

console.log('\n2. 多态（较快）:');
console.time('polymorphic');
for (let i = 0; i < 100000; i++) {
    getX({ x: 1 });
    getX({ x: 2, y: 3 });
    getX({ x: 4, y: 5, z: 6 });
}
console.timeEnd('polymorphic');

console.log('\n建议: 保持对象结构一致');</code></pre>
                </div>
                <button class="run-btn">▶ 运行代码</button>
                <div class="output"></div>
            </div>
            
            <div class="code-example">
                <h3>示例 3：数组元素类型</h3>
                <div class="code-block">
                    <pre><code>// 数组元素类型影响性能
console.log('=== 数组类型 ===\n');

console.log('1. SMI 数组（最快）:');
const smi = [1, 2, 3, 4, 5];
console.time('smi');
for (let i = 0; i < 100000; i++) {
    smi[i % 5];
}
console.timeEnd('smi');

console.log('\n2. Double 数组:');
const doubles = [1.1, 2.2, 3.3, 4.4, 5.5];
console.time('double');
for (let i = 0; i < 100000; i++) {
    doubles[i % 5];
}
console.timeEnd('double');

console.log('\n3. 混合数组（最慢）:');
const mixed = [1, 'str', {}, null, true];
console.time('mixed');
for (let i = 0; i < 100000; i++) {
    mixed[i % 5];
}
console.timeEnd('mixed');

console.log('\n建议: 保持数组元素类型一致');</code></pre>
                </div>
                <button class="run-btn">▶ 运行代码</button>
                <div class="output"></div>
            </div>
            
            <div class="code-example">
                <h3>示例 4：删除属性的代价</h3>
                <div class="code-block">
                    <pre><code>// delete 操作的性能影响
console.log('=== delete 性能 ===\n');

console.log('1. 使用 delete:');
const obj1 = { x: 1, y: 2, z: 3 };
console.time('delete');
for (let i = 0; i < 100000; i++) {
    const temp = { x: 1, y: 2, z: 3 };
    delete temp.z;
    temp.x;
}
console.timeEnd('delete');

console.log('\n2. 设为 undefined:');
const obj2 = { x: 1, y: 2, z: 3 };
console.time('undefined');
for (let i = 0; i < 100000; i++) {
    const temp = { x: 1, y: 2, z: 3 };
    temp.z = undefined;
    temp.x;
}
console.timeEnd('undefined');

console.log('\n建议:');
console.log('  ✓ 设为 null/undefined');
console.log('  ✗ 避免 delete');</code></pre>
                </div>
                <button class="run-btn">▶ 运行代码</button>
                <div class="output"></div>
            </div>
            
            <div class="code-example">
                <h3>示例 5：函数内联</h3>
                <div class="code-block">
                    <pre><code>// 小函数易被内联
console.log('=== 函数内联 ===\n');

function square(x) {
    return x * x;
}

function sumOfSquares(a, b) {
    return square(a) + square(b);
}

console.log('调用小函数:');
console.time('inline-candidate');
let result = 0;
for (let i = 0; i < 1000000; i++) {
    result += sumOfSquares(i, i + 1);
}
console.timeEnd('inline-candidate');
console.log('  结果:', result);

console.log('\n说明:');
console.log('  小函数 square 可能被内联');
console.log('  减少函数调用开销');
console.log('  V8 自动优化');</code></pre>
                </div>
                <button class="run-btn">▶ 运行代码</button>
                <div class="output"></div>
            </div>
            
            <div class="code-example">
                <h3>示例 6：预热优化</h3>
                <div class="code-block">
                    <pre><code>// 函数预热让 V8 优化
console.log('=== 函数预热 ===\n');

function compute(x) {
    return x * x + x * 2 + 1;
}

console.log('1. 冷启动（未优化）:');
console.time('cold');
for (let i = 0; i < 100; i++) {
    compute(i);
}
console.timeEnd('cold');

console.log('\n2. 预热:');
for (let i = 0; i < 10000; i++) {
    compute(i);
}
console.log('  执行 10000 次预热');

console.log('\n3. 热运行（已优化）:');
console.time('hot');
for (let i = 0; i < 100; i++) {
    compute(i);
}
console.timeEnd('hot');

console.log('\n说明:');
console.log('  热运行通常更快');
console.log('  V8 已生成优化代码');</code></pre>
                </div>
                <button class="run-btn">▶ 运行代码</button>
                <div class="output"></div>
            </div>
        </div>
    </div>
    
    <script src="../assets/js/common.js"></script>
</body>
</html>
