<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>事件循环机制 - JavaScript 深度学习</title>
    <link rel="stylesheet" href="../assets/css/main.css">
    <link rel="stylesheet" href="../assets/css/page.css">
</head>
<body>
    <div class="page-layout">
        <div class="doc-panel">
            <h1>事件循环机制</h1>
            
            <h2>概述</h2>
            <p>事件循环（Event Loop）是 JavaScript 实现异步编程的核心机制。理解事件循环是掌握 JavaScript 异步编程的关键。</p>
            
            <h2>一、JavaScript 执行模型</h2>
            
            <h3>1.1 单线程特性</h3>
            <div class="info">
                <p>JavaScript 是单线程语言，同一时间只能执行一个任务。但通过事件循环机制，可以实现异步非阻塞操作。</p>
            </div>
            
            <h3>1.2 运行时组成</h3>
            <ul>
                <li><strong>调用栈（Call Stack）</strong>：执行同步代码</li>
                <li><strong>Web APIs</strong>：浏览器提供的异步 API</li>
                <li><strong>任务队列（Task Queue）</strong>：存放待执行的回调</li>
                <li><strong>事件循环（Event Loop）</strong>：协调调度</li>
            </ul>
            
            <h2>二、事件循环流程</h2>
            
            <h3>2.1 执行流程</h3>
            <pre><code>1. 执行同步代码（调用栈）
2. 调用栈清空后，检查微任务队列
3. 执行所有微任务
4. 渲染更新（如果需要）
5. 从宏任务队列取一个任务执行
6. 回到步骤 2</code></pre>
            
            <h3>2.2 可视化流程</h3>
            <pre><code>┌───────────────────────────┐
│    调用栈（Call Stack）    │
└───────────────────────────┘
            ↓
┌───────────────────────────┐
│   微任务队列（Microtasks）  │
│   - Promise.then          │
│   - queueMicrotask        │
│   - MutationObserver      │
└───────────────────────────┘
            ↓
┌───────────────────────────┐
│   宏任务队列（Macrotasks）  │
│   - setTimeout            │
│   - setInterval           │
│   - setImmediate (Node)   │
│   - I/O                   │
└───────────────────────────┘</code></pre>
            
            <h2>三、宏任务 vs 微任务</h2>
            
            <h3>3.1 宏任务（Macrotask）</h3>
            <table>
                <thead>
                    <tr>
                        <th>API</th>
                        <th>说明</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><code>setTimeout</code></td>
                        <td>延时执行</td>
                    </tr>
                    <tr>
                        <td><code>setInterval</code></td>
                        <td>定时执行</td>
                    </tr>
                    <tr>
                        <td><code>setImmediate</code></td>
                        <td>立即执行（Node.js）</td>
                    </tr>
                    <tr>
                        <td><code>I/O 操作</code></td>
                        <td>文件读写、网络请求</td>
                    </tr>
                    <tr>
                        <td><code>UI 渲染</code></td>
                        <td>浏览器渲染</td>
                    </tr>
                </tbody>
            </table>
            
            <h3>3.2 微任务（Microtask）</h3>
            <table>
                <thead>
                    <tr>
                        <th>API</th>
                        <th>说明</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><code>Promise.then/catch/finally</code></td>
                        <td>Promise 回调</td>
                    </tr>
                    <tr>
                        <td><code>queueMicrotask</code></td>
                        <td>直接添加微任务</td>
                    </tr>
                    <tr>
                        <td><code>MutationObserver</code></td>
                        <td>DOM 变化监听</td>
                    </tr>
                    <tr>
                        <td><code>process.nextTick</code></td>
                        <td>Node.js 特有</td>
                    </tr>
                </tbody>
            </table>
            
            <h3>3.3 执行优先级</h3>
            <div class="spec">
                <ol>
                    <li>执行当前宏任务（同步代码）</li>
                    <li>执行所有微任务</li>
                    <li>执行下一个宏任务</li>
                </ol>
                <p><strong>关键：</strong>微任务在下一个宏任务之前全部执行。</p>
            </div>
            
            <h2>四、执行顺序示例</h2>
            
            <h3>4.1 基本示例</h3>
            <pre><code>console.log('1');

setTimeout(() => {
    console.log('2');
}, 0);

Promise.resolve().then(() => {
    console.log('3');
});

console.log('4');

// 输出顺序: 1, 4, 3, 2</code></pre>
            
            <h3>4.2 复杂示例</h3>
            <pre><code>console.log('start');

setTimeout(() => {
    console.log('timeout1');
    Promise.resolve().then(() => {
        console.log('promise1');
    });
}, 0);

Promise.resolve().then(() => {
    console.log('promise2');
    setTimeout(() => {
        console.log('timeout2');
    }, 0);
});

console.log('end');

// 输出: start, end, promise2, timeout1, promise1, timeout2</code></pre>
            
            <h2>五、async/await 与事件循环</h2>
            
            <h3>5.1 async/await 本质</h3>
            <pre><code>async function example() {
    console.log('1');
    await Promise.resolve();
    console.log('2');
}

// 等价于
function example() {
    console.log('1');
    return Promise.resolve().then(() => {
        console.log('2');
    });
}</code></pre>
            
            <h3>5.2 执行顺序</h3>
            <pre><code>async function async1() {
    console.log('async1 start');
    await async2();
    console.log('async1 end');
}

async function async2() {
    console.log('async2');
}

console.log('script start');
async1();
console.log('script end');

// 输出:
// script start
// async1 start
// async2
// script end
// async1 end</code></pre>
            
            <h2>六、浏览器 vs Node.js</h2>
            
            <h3>6.1 浏览器事件循环</h3>
            <ul>
                <li>宏任务：setTimeout、setInterval、I/O、UI 渲染</li>
                <li>微任务：Promise、MutationObserver、queueMicrotask</li>
            </ul>
            
            <h3>6.2 Node.js 事件循环</h3>
            <pre><code>   ┌───────────────────────┐
┌─>│        timers         │ setTimeout/setInterval
│  └───────┬───────────────┘
│  ┌───────┴───────────────┐
│  │   pending callbacks   │ I/O 回调
│  └───────┬───────────────┘
│  ┌───────┴───────────────┐
│  │     idle, prepare     │ 内部使用
│  └───────┬───────────────┘
│  ┌───────┴───────────────┐
│  │        poll           │ I/O 轮询
│  └───────┬───────────────┘
│  ┌───────┴───────────────┐
│  │        check          │ setImmediate
│  └───────┬───────────────┘
│  ┌───────┴───────────────┐
│  │    close callbacks    │ close 事件
│  └───────────────────────┘
└──────────────────────────┘</code></pre>
            
            <h3>6.3 process.nextTick</h3>
            <pre><code>// Node.js 中优先级最高
console.log('start');

process.nextTick(() => {
    console.log('nextTick');
});

Promise.resolve().then(() => {
    console.log('promise');
});

console.log('end');

// 输出: start, end, nextTick, promise</code></pre>
            
            <h2>七、常见陷阱</h2>
            
            <h3>7.1 setTimeout(fn, 0)</h3>
            <div class="warning">
                <p><code>setTimeout(fn, 0)</code> 不是立即执行，而是在下一个宏任务执行。</p>
                <pre><code>console.log('1');
setTimeout(() => console.log('2'), 0);
Promise.resolve().then(() => console.log('3'));
console.log('4');

// 输出: 1, 4, 3, 2</code></pre>
            </div>
            
            <h3>7.2 微任务队列饥饿</h3>
            <div class="warning">
                <p>大量微任务可能阻塞宏任务执行：</p>
                <pre><code>function addMicrotask() {
    Promise.resolve().then(() => {
        console.log('micro');
        addMicrotask(); // 无限添加微任务
    });
}

addMicrotask();
setTimeout(() => console.log('macro'), 0); // 永远不执行</code></pre>
            </div>
            
            <h2>八、性能优化</h2>
            
            <div class="tip">
                <ol>
                    <li><strong>拆分长任务</strong>：避免阻塞事件循环</li>
                    <li><strong>使用 requestIdleCallback</strong>：在空闲时执行</li>
                    <li><strong>Web Workers</strong>：CPU 密集任务移到 Worker</li>
                    <li><strong>避免同步 I/O</strong>：使用异步 API</li>
                </ol>
            </div>
            
            <h2>参考资料</h2>
            <ul>
                <li><a href="https://html.spec.whatwg.org/multipage/webappapis.html#event-loops" target="_blank">HTML Standard - Event Loops</a></li>
                <li><a href="https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/" target="_blank">Node.js Event Loop</a></li>
                <li><a href="https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/" target="_blank">Tasks, microtasks, queues and schedules</a></li>
            </ul>
            
            <div class="nav-links">
                <a href="09-async-await.html" class="nav-link prev">上一节：async/await</a>
                <a href="../index.html" class="nav-link home">返回首页</a>
                <a href="10-dom.html" class="nav-link next">下一节：DOM 操作</a>
            </div>
        </div>
        
        <div class="code-panel">
            <h2 style="color: #60a5fa; margin-bottom: 1.5rem;">💻 交互式代码示例</h2>
            
            <div class="code-example">
                <h3>示例 1：基本执行顺序</h3>
                <div class="code-block">
                    <pre><code>console.log('1. 同步代码开始');

setTimeout(() => {
    console.log('4. setTimeout（宏任务）');
}, 0);

Promise.resolve().then(() => {
    console.log('3. Promise.then（微任务）');
});

console.log('2. 同步代码结束');

// 执行顺序:
// 1. 同步代码 -> 调用栈
// 2. 微任务 -> Promise.then
// 3. 宏任务 -> setTimeout</code></pre>
                </div>
                <button class="run-btn">▶ 运行代码</button>
                <div class="output"></div>
            </div>
            
            <div class="code-example">
                <h3>示例 2：宏任务 vs 微任务</h3>
                <div class="code-block">
                    <pre><code>console.log('=== 宏任务 vs 微任务 ===\n');

// 宏任务
setTimeout(() => {
    console.log('宏任务1');
}, 0);

setTimeout(() => {
    console.log('宏任务2');
}, 0);

// 微任务
Promise.resolve().then(() => {
    console.log('微任务1');
});

Promise.resolve().then(() => {
    console.log('微任务2');
});

console.log('同步代码');

// 输出顺序:
// 同步代码
// 微任务1
// 微任务2
// 宏任务1
// 宏任务2</code></pre>
                </div>
                <button class="run-btn">▶ 运行代码</button>
                <div class="output"></div>
            </div>
            
            <div class="code-example">
                <h3>示例 3：复杂执行顺序</h3>
                <div class="code-block">
                    <pre><code>console.log('start');

setTimeout(() => {
    console.log('timeout1');
    Promise.resolve().then(() => {
        console.log('promise in timeout1');
    });
}, 0);

Promise.resolve().then(() => {
    console.log('promise1');
    setTimeout(() => {
        console.log('timeout in promise1');
    }, 0);
});

setTimeout(() => {
    console.log('timeout2');
}, 0);

Promise.resolve().then(() => {
    console.log('promise2');
});

console.log('end');</code></pre>
                </div>
                <button class="run-btn">▶ 运行代码</button>
                <div class="output"></div>
            </div>
            
            <div class="code-example">
                <h3>示例 4：async/await 执行顺序</h3>
                <div class="code-block">
                    <pre><code>async function async1() {
    console.log('async1 start');
    await async2();
    console.log('async1 end');
}

async function async2() {
    console.log('async2');
}

console.log('script start');

setTimeout(() => {
    console.log('setTimeout');
}, 0);

async1();

new Promise(resolve => {
    console.log('promise1');
    resolve();
}).then(() => {
    console.log('promise2');
});

console.log('script end');</code></pre>
                </div>
                <button class="run-btn">▶ 运行代码</button>
                <div class="output"></div>
            </div>
            
            <div class="code-example">
                <h3>示例 5：微任务链</h3>
                <div class="code-block">
                    <pre><code>console.log('开始');

Promise.resolve()
    .then(() => {
        console.log('微任务1');
        return Promise.resolve();
    })
    .then(() => {
        console.log('微任务2');
    });

Promise.resolve()
    .then(() => {
        console.log('微任务3');
    })
    .then(() => {
        console.log('微任务4');
    });

setTimeout(() => {
    console.log('宏任务');
}, 0);

console.log('结束');

// 微任务会在同一轮事件循环中全部执行完</code></pre>
                </div>
                <button class="run-btn">▶ 运行代码</button>
                <div class="output"></div>
            </div>
            
            <div class="code-example">
                <h3>示例 6：实际应用场景</h3>
                <div class="code-block">
                    <pre><code>// 模拟数据获取
function fetchData(id) {
    return new Promise(resolve => {
        console.log(`开始获取数据 ${id}`);
        setTimeout(() => {
            console.log(`数据 ${id} 获取完成`);
            resolve(`Data ${id}`);
        }, Math.random() * 500);
    });
}

// 场景1：串行获取
async function serialFetch() {
    console.log('=== 串行获取 ===');
    const data1 = await fetchData(1);
    const data2 = await fetchData(2);
    console.log('结果:', [data1, data2]);
}

// 场景2：并行获取
async function parallelFetch() {
    console.log('\n=== 并行获取 ===');
    const [data1, data2] = await Promise.all([
        fetchData(3),
        fetchData(4)
    ]);
    console.log('结果:', [data1, data2]);
}

// 执行
serialFetch().then(() => parallelFetch());</code></pre>
                </div>
                <button class="run-btn">▶ 运行代码</button>
                <div class="output"></div>
            </div>
        </div>
    </div>
    
    <script src="../assets/js/common.js"></script>
</body>
</html>
