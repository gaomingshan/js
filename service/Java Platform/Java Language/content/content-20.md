# GC 的基本原理与算法

## 概述

垃圾回收（Garbage Collection, GC）是 Java 自动内存管理的核心机制。程序员无需手动释放内存，JVM 自动回收不可达对象，避免内存泄漏和悬空指针问题。

理解 GC 的关键：
- **可达性分析**：判断对象是否存活
- **GC Roots**：可达性分析的起点
- **三种基本算法**：标记-清除、标记-复制、标记-整理
- **Stop-The-World**：GC 时暂停应用线程

本章聚焦 GC 的基本原理与核心算法。

---

## 1. 对象存活判定

### 引用计数法（Reference Counting）

**原理**：为每个对象维护引用计数器

**实现**：
```
对象创建：count = 1
被引用：count++
引用失效：count--
count == 0：回收对象
```

**优点**：
- 实现简单
- 回收及时

**缺点**：
- **无法解决循环引用**

**循环引用示例**：

```java
class Node {
    Node next;
}

Node a = new Node();
Node b = new Node();
a.next = b;
b.next = a;

a = null;
b = null;
// a 和 b 对象互相引用，引用计数 > 0，无法回收
```

**Python 的解决方案**：
- 引用计数 + 标记-清除（处理循环引用）

**Java 不使用引用计数法**：主流 JVM（HotSpot）使用可达性分析。

### 可达性分析算法（Reachability Analysis）

**原理**：从 GC Roots 出发，遍历对象引用链，不可达对象即为垃圾

**GC Roots 包括**：

1. **虚拟机栈**（局部变量表）中的引用
2. **方法区**（静态变量）
3. **方法区**（常量引用）
4. **本地方法栈**（JNI 引用）
5. **活跃线程**
6. **被 Synchronized 锁持有的对象**

**可达性示例**：

```
GC Roots
  ├─> Object A
  │    └─> Object B
  │         └─> Object C
  └─> Object D

Object E ← 孤立，不可达，可回收
```

**算法流程**：

1. 标记所有 GC Roots
2. 遍历引用链，标记可达对象
3. 未被标记的对象即为垃圾

---

## 2. 标记-清除算法（Mark-Sweep）

### 算法原理

**两个阶段**：

1. **标记阶段**：标记所有存活对象
2. **清除阶段**：回收未标记的对象

**示意图**：

```
标记前：
[对象A] [对象B] [垃圾C] [对象D] [垃圾E]

标记后：
[对象A*] [对象B*] [垃圾C] [对象D*] [垃圾E]
（*表示已标记）

清除后：
[对象A] [对象B] [空闲] [对象D] [空闲]
```

### 优点

- 实现简单
- 适用于老年代（对象存活率高）

### 缺点

**1. 内存碎片**：

```
[对象A] [空闲] [对象B] [空闲] [对象C]
```

大对象可能无法分配（虽然总空闲空间充足）。

**2. 效率问题**：

- 标记和清除都需要遍历堆
- 时间复杂度：O(堆大小)

**3. Stop-The-World**：

- GC 期间暂停应用线程
- 防止对象引用关系变化

---

## 3. 标记-复制算法（Mark-Copy）

### 算法原理

**两个区域**：From 区和 To 区

**流程**：

1. 对象分配在 From 区
2. GC 时，将 From 区存活对象复制到 To 区
3. 清空 From 区
4. 交换 From 和 To 区角色

**示意图**：

```
GC 前：
From 区: [对象A] [垃圾B] [对象C] [垃圾D]
To 区:   [空]

GC 后：
From 区: [空]
To 区:   [对象A] [对象C]

交换后：
From 区: [对象A] [对象C]
To 区:   [空]
```

### 优点

1. **无内存碎片**：对象连续分配
2. **效率高**：只遍历存活对象
3. **分配快**：指针碰撞分配

### 缺点

**内存利用率低**：

- 需要两倍空间
- 实际可用空间只有一半

**适用场景**：

- 新生代（对象存活率低，复制对象少）

### 新生代的优化

**Eden + Survivor 模型**：

```
新生代
├── Eden 区（80%）
├── Survivor0 区（10%）
└── Survivor1 区（10%）
```

**流程**：

1. 对象分配在 Eden
2. Minor GC 时，存活对象复制到 Survivor0
3. 下次 GC，Eden + Survivor0 存活对象复制到 Survivor1
4. 交替使用 Survivor0 和 Survivor1

**内存利用率**：90%（Eden + 1个 Survivor）

---

## 4. 标记-整理算法（Mark-Compact）

### 算法原理

**两个阶段**：

1. **标记阶段**：标记存活对象
2. **整理阶段**：移动存活对象到一端，清理边界外内存

**示意图**：

```
标记后：
[对象A*] [垃圾B] [对象C*] [垃圾D] [对象E*]

整理后：
[对象A] [对象C] [对象E] [空闲空间]
```

### 优点

1. **无内存碎片**
2. **内存利用率高**（无需预留空间）
3. **适用于老年代**

### 缺点

**移动对象开销大**：

- 需要更新所有指向该对象的引用
- 需要 Stop-The-World

**适用场景**：

- 老年代（对象存活率高，移动对象少）

---

## 5. Stop-The-World（STW）

### 定义

**Stop-The-World**：GC 时暂停所有应用线程

**原因**：

- 保证对象引用关系不变
- 避免标记过程中对象状态改变

### 安全点（Safepoint）

**定义**：线程可以安全暂停的位置

**选择原则**：

- 方法调用
- 循环跳转
- 异常跳转

**不是安全点**：

- 正在执行的指令中间
- 本地方法调用中

**实现**：

1. JVM 设置全局标志位
2. 线程执行到安全点时，检查标志位
3. 如果标志位已设置，线程挂起

**主动式中断**：

```java
while (running) {
    // 安全点检查
    if (gcRequested) {
        safepoint();
    }
    
    // 业务逻辑
    doWork();
}
```

### 安全区域（Safe Region）

**定义**：一段代码范围，期间对象引用关系不变

**典型场景**：

- 线程 Sleep
- 线程 Blocked（等待锁）

**流程**：

1. 线程进入安全区域，标记自己
2. GC 开始，忽略安全区域内的线程
3. 线程离开安全区域前，检查 GC 是否完成
4. 未完成则等待，完成则继续执行

---

## 6. 三色标记法

### 三种颜色

**白色**：未访问

**灰色**：已访问，但引用的对象未全部访问

**黑色**：已访问，且引用的对象全部访问

### 标记流程

**初始状态**：

```
所有对象：白色
GC Roots：灰色
```

**迭代**：

1. 从灰色对象出发，访问其引用的白色对象
2. 将白色对象标记为灰色
3. 将当前灰色对象标记为黑色
4. 重复直到无灰色对象

**结束**：

```
黑色对象：存活
白色对象：垃圾
```

### 并发标记的问题

**对象消失问题**：

**场景**：

```
初始：
  黑色对象 A → 灰色对象 B → 白色对象 C

应用线程执行：
  A.ref = C;  // 黑色对象引用白色对象
  B.ref = null;  // 删除灰色到白色的引用

结果：
  C 仍为白色，但被 A 引用
  GC 结束后，C 被错误回收
```

**解决方案**：

**1. 增量更新（Incremental Update）**：

- 黑色对象引用白色对象时，将黑色对象重新标记为灰色

**2. 原始快照（SATB, Snapshot At The Beginning）**：

- 删除引用时，记录被删除的引用
- GC 结束前处理这些引用

---

## 易错点与边界行为

### 1. finalize() 方法的影响

**对象复活**：

```java
class Demo {
    static Demo instance;
    
    @Override
    protected void finalize() throws Throwable {
        instance = this;  // 对象复活
    }
}
```

**GC 流程**：

1. 第一次标记：对象不可达
2. 执行 finalize()，对象复活
3. 下次 GC：对象再次不可达
4. **finalize() 只执行一次**，第二次直接回收

### 2. 软引用、弱引用、虚引用

**强引用**：

```java
Object obj = new Object();  // 强引用，永不回收
```

**软引用**：

```java
SoftReference<byte[]> soft = new SoftReference<>(new byte[1024]);
// 内存不足时回收
```

**弱引用**：

```java
WeakReference<byte[]> weak = new WeakReference<>(new byte[1024]);
// 下次 GC 时回收
```

**虚引用**：

```java
PhantomReference<byte[]> phantom = new PhantomReference<>(new byte[1024], queue);
// 无法通过引用获取对象，用于跟踪对象回收
```

### 3. 大对象直接进入老年代

**大对象阈值**：`-XX:PretenureSizeThreshold`

```bash
java -XX:PretenureSizeThreshold=1m MyApp
```

**超过阈值的对象直接分配到老年代**，避免新生代频繁复制。

---

## 实际推导案例

### 案例：为什么新生代使用复制算法？

**新生代特点**：

- 对象存活率低（约 1%-10%）
- 对象生命周期短

**标记-清除的问题**：

- 内存碎片严重
- 效率低（需遍历大量垃圾）

**标记-复制的优势**：

- 只复制少量存活对象（1%-10%）
- 无内存碎片
- 分配快速（指针碰撞）

**内存利用率优化**：

- 传统复制算法：50% 利用率
- Eden + Survivor：90% 利用率

### 案例：为什么老年代使用标记-整理？

**老年代特点**：

- 对象存活率高（约 90%）
- 对象生命周期长

**标记-复制的问题**：

- 需要复制大量对象（90%）
- 内存利用率低（50%）

**标记-整理的优势**：

- 只移动少量对象（填补空隙）
- 内存利用率高（100%）
- 无内存碎片

---

## 关键点总结

1. **可达性分析**：从 GC Roots 出发，遍历引用链判断存活
2. **标记-清除**：简单但有内存碎片
3. **标记-复制**：无碎片，适用于新生代（低存活率）
4. **标记-整理**：无碎片，适用于老年代（高存活率）
5. **Stop-The-World**：GC 时暂停应用线程，通过安全点实现
6. **三色标记**：白色（垃圾）、灰色（待处理）、黑色（存活）

---

## 深入一点

### 使用 jstat 监控 GC

**查看 GC 统计**：

```bash
jstat -gc <pid> 1000
```

**输出**：

```
 S0C    S1C    S0U    S1U      EC       EU        OC         OU       MC     MU
10240  10240    0    8192   81920    40960    174080     87040   51200  45056
```

- S0C/S1C：Survivor 0/1 容量
- S0U/S1U：Survivor 0/1 使用量
- EC/EU：Eden 容量/使用量
- OC/OU：老年代容量/使用量

### GC 日志分析

**启用 GC 日志**：

```bash
java -Xlog:gc*:file=gc.log -XX:+PrintGCDetails MyApp
```

**日志示例**：

```
[GC (Allocation Failure) [PSYoungGen: 65536K->8192K(76288K)] 65536K->8200K(251392K), 0.0123456 secs]
```

- `PSYoungGen`：新生代回收
- `65536K->8192K`：回收前后新生代大小
- `(76288K)`：新生代总大小
- `0.0123456 secs`：耗时 12.3 ms

### 可视化 GC 日志

**工具**：GCViewer、GCEasy

**分析指标**：

- GC 频率
- GC 耗时
- 内存使用趋势
- Stop-The-World 时间

---

## 参考资料

- 《深入理解 Java 虚拟机（第3版）》- 第3章 垃圾收集器与内存分配策略
- 《Java 性能权威指南》- 第5章垃圾收集
- Oracle 官方文档：[Garbage Collection Tuning](https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/)
- 工具：jstat、GCViewer、GCEasy
