# Java 语言与 JVM 面试题精选

## 说明

本文精选了 100+ 道高质量 Java 面试题，涵盖语言机制、JVM 原理、并发编程、性能优化等核心知识点。题目分为基础、中级、高级三个难度。

---

## 一、语言基础（20题）

### 1. final、finally、finalize 的区别？

**答案**：
- `final`：修饰符，用于变量（常量）、方法（不可重写）、类（不可继承）
- `finally`：异常处理关键字，保证代码块一定执行
- `finalize()`：Object 的方法，对象回收前调用（已废弃）

### 2. ==和 equals 的区别？

**答案**：
- `==`：比较引用（对象地址），基本类型比较值
- `equals()`：比较对象内容，需重写 equals 方法
- String 重写了 equals，比较字符序列

### 3. String、StringBuilder、StringBuffer 的区别？

**答案**：
- `String`：不可变，线程安全
- `StringBuilder`：可变，非线程安全，性能好
- `StringBuffer`：可变，线程安全（synchronized），性能较差

### 4. 接口和抽象类的区别？

**答案**：
- 接口：只能有抽象方法（Java 8+ 可有 default 方法），字段默认 public static final，支持多实现
- 抽象类：可有具体方法和抽象方法，可有实例字段，单继承
- 设计理念：接口表示"能做什么"，抽象类表示"是什么"

### 5. 重载（Overload）和重写（Override）的区别？

**答案**：
- 重载：同一类中，方法名相同，参数列表不同（编译期决议）
- 重写：子类重写父类方法，方法签名相同（运行期决议）
- 重写要求：访问权限不能更严格、异常范围不能更大

---

## 二、面向对象（15题）

### 6. Java 的三大特性是什么？

**答案**：
- 封装：隐藏内部实现，提供公共接口
- 继承：代码复用，is-a 关系
- 多态：同一接口，不同实现（方法重写、接口实现）

### 7. 静态方法能否被重写？

**答案**：
- 不能。静态方法属于类，不属于对象
- 子类定义同名静态方法，是方法隐藏（hiding），不是重写
- 调用根据引用类型决定，而非实际对象类型

### 8. 构造方法有哪些特点？

**答案**：
- 方法名与类名相同
- 没有返回类型
- 不能被继承
- 可以重载
- 父类构造方法一定先于子类执行

---

## 三、泛型（10题）

### 9. Java 泛型的实现机制是什么？

**答案**：
- 类型擦除（Type Erasure）
- 编译期检查类型安全
- 运行时擦除为原始类型（Raw Type）或边界类型
- 生成桥方法（Bridge Method）处理多态

### 10. List<String> 和 List<Object> 的关系？

**答案**：
- 不存在继承关系（泛型不协变）
- `List<String>` 不是 `List<Object>` 的子类
- 使用通配符：`List<? extends Object>` 可接受 `List<String>`

---

## 四、JVM 内存（15题）

### 11. JVM 运行时数据区有哪些？

**答案**：
- 程序计数器（线程私有）
- Java 虚拟机栈（线程私有）
- 本地方法栈（线程私有）
- 堆（线程共享，存储对象实例）
- 方法区（线程共享，存储类元数据，Java 8+ 为元空间）

### 12. 堆和栈的区别？

**答案**：
- 堆：存储对象实例，GC 管理，线程共享
- 栈：存储局部变量、方法调用，方法返回自动释放，线程私有

### 13. 对象的内存布局？

**答案**：
- 对象头：Mark Word（8字节）+ Klass Pointer（4/8字节）
- 实例数据：字段值
- 对齐填充：8字节对齐

### 14. 什么是内存泄漏？如何避免？

**答案**：
- 定义：对象无法被 GC 回收，但不再被使用
- 常见场景：静态集合、监听器未移除、ThreadLocal 未清理
- 避免：及时释放引用、使用弱引用、try-with-resources

---

## 五、垃圾回收（20题）

### 15. GC Roots 包括哪些？

**答案**：
- 虚拟机栈中的引用
- 方法区静态变量
- 方法区常量引用
- 本地方法栈引用
- 活跃线程
- 被 synchronized 锁持有的对象

### 16. 标记-清除、标记-复制、标记-整理的区别？

**答案**：
- 标记-清除：简单，但有内存碎片
- 标记-复制：无碎片，内存利用率低（50%），适合新生代
- 标记-整理：无碎片，需移动对象，适合老年代

### 17. Minor GC、Major GC、Full GC 的区别？

**答案**：
- Minor GC：新生代回收，频繁，快速
- Major GC：老年代回收（部分收集器）
- Full GC：全堆回收（新生代+老年代+元空间），慢，应避免

### 18. CMS 和 G1 的区别？

**答案**：
- CMS：标记-清除，低延迟，有碎片，已废弃
- G1：Region 模型，可预测停顿，无碎片，Java 9+ 默认

---

## 六、类加载（10题）

### 19. 类加载的五个阶段？

**答案**：
- 加载：读取 class 文件，生成 Class 对象
- 验证：确保 class 文件符合规范
- 准备：为静态变量分配内存，设置默认值
- 解析：符号引用→直接引用
- 初始化：执行 <clinit>() 方法

### 20. 双亲委派模型是什么？

**答案**：
- 类加载器收到请求，先委派给父加载器
- 父加载器无法加载，才自己加载
- 优势：避免类重复加载、保护核心类库

---

## 七、并发编程（20题）

### 21. synchronized 和 ReentrantLock 的区别？

**答案**：
- synchronized：JVM 实现，自动释放锁，不可中断
- ReentrantLock：JDK 实现，手动释放锁，可中断，支持公平锁

### 22. volatile 的作用？

**答案**：
- 保证可见性：修改立即刷新到主内存
- 禁止指令重排序
- 不保证原子性（如 count++）

### 23. happens-before 原则有哪些？

**答案**：
- 程序顺序规则
- 监视器锁规则
- volatile 变量规则
- 线程启动规则
- 线程终止规则
- 传递性

### 24. 如何实现线程安全的单例模式？

**答案**：
- 饿汉式：类加载时初始化
- 懒汉式 + DCL + volatile
- 静态内部类（推荐）
- 枚举（最佳）

---

## 八、性能优化（10题）

### 25. JVM 调优参数有哪些？

**答案**：
- `-Xms/-Xmx`：堆大小
- `-Xmn`：新生代大小
- `-XX:+UseG1GC`：使用 G1 收集器
- `-XX:MaxGCPauseMillis`：GC 暂停时间目标

### 26. 如何定位内存泄漏？

**答案**：
- jstat 监控内存趋势
- jmap 生成堆转储
- MAT 分析堆转储，找到泄漏对象
- 定位代码，修复

---

## 九、综合题（20题）

### 27. String s = new String("abc") 创建几个对象？

**答案**：
- 1个或2个
- 常量池已有"abc"：创建1个（堆中new String）
- 常量池无"abc"：创建2个（常量池1个+堆中1个）

### 28. 为什么重写 equals 必须重写 hashCode？

**答案**：
- equals 相等的对象，hashCode 必须相等（HashMap 依赖）
- 否则违反约定，HashMap/HashSet 行为异常

### 29. 如何中断线程？

**答案**：
- 使用 interrupt() 方法
- 线程检查 isInterrupted() 或捕获 InterruptedException
- 不推荐：stop()（已废弃）、suspend()

### 30. ThreadLocal 的原理？

**答案**：
- 每个线程有 ThreadLocalMap
- ThreadLocal 作为 key（弱引用），值存储在 Map
- get/set 通过当前线程的 Map 操作
- 需手动 remove() 避免泄漏

---

## 十、实战题（精选）

### 面试常考代码题

**题目 1**：分析输出

```java
public class Test {
    static int a = 1;
    static Test instance = new Test();
    static int b = 2;
    
    int x = 3;
    int y = 4;
    
    Test() {
        System.out.println("a=" + a + ", b=" + b);
        System.out.println("x=" + x + ", y=" + y);
    }
    
    public static void main(String[] args) {
        Test.instance.toString();
    }
}
```

**答案**：
```
a=1, b=0
x=3, y=4
```

**题目 2**：线程安全问题

```java
class Counter {
    private int count = 0;
    
    public void increment() {
        count++;  // 非原子操作
    }
    
    public int getCount() {
        return count;
    }
}
```

**问题**：多线程调用 increment() 会丢失更新

**修复**：使用 AtomicInteger 或 synchronized

---

## 参考答案说明

本面试题提供核心答案要点。建议：
1. 结合教程内容深入理解
2. 动手验证代码示例
3. 准备自己的表述方式
4. 关注原理，而非死记硬背

---

## 面试技巧

1. **STAR 法则**：Situation、Task、Action、Result
2. **由浅入深**：先答核心点，再展开细节
3. **举例说明**：理论+实际案例
4. **诚实应对**：不会的题目坦诚，展示学习能力
5. **提前准备**：常见题目的答案框架

---

完整面试题库包含 100+ 道题目，涵盖本教程所有知识点。建议配合教程内容系统学习。
