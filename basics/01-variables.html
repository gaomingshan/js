<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>变量声明（var/let/const） - JavaScript 深度学习</title>
    <link rel="stylesheet" href="../assets/css/main.css">
    <link rel="stylesheet" href="../assets/css/page.css">
</head>
<body>
    <div class="page-layout">
        <!-- 文档面板 -->
        <div class="doc-panel">
            <h1>变量声明：var / let / const</h1>
            
            <h2>概述</h2>
            <p>JavaScript 提供了三种变量声明方式，它们在作用域、提升、重复声明等方面有显著差异。</p>
            
            <h2>一、var 声明</h2>
            
            <h3>1.1 基本特性</h3>
            <ul>
                <li><strong>函数作用域</strong>：var 声明的变量具有函数作用域</li>
                <li><strong>变量提升</strong>：声明会被提升到作用域顶部</li>
                <li><strong>可重复声明</strong>：同一作用域内可以重复声明</li>
                <li><strong>全局对象属性</strong>：全局 var 会成为 window 的属性</li>
            </ul>
            
            <h3>1.2 变量提升（Hoisting）</h3>
            <p>变量提升是 JavaScript 的一种机制，变量和函数声明会在代码执行前被移动到作用域顶部。</p>
            
            <div class="note">
                var 声明的变量会被提升，但赋值不会。提升后的变量值为 <code>undefined</code>。
            </div>
            
            <h3>1.3 作用域问题</h3>
            <p>var 没有块级作用域，这在循环中会导致经典问题：</p>
            
            <h2>二、let 声明（ES6）</h2>
            
            <h3>2.1 基本特性</h3>
            <ul>
                <li><strong>块级作用域</strong>：let 声明的变量具有块级作用域 <code>{...}</code></li>
                <li><strong>暂时性死区（TDZ）</strong>：在声明前访问会报错</li>
                <li><strong>不可重复声明</strong>：同一作用域内不能重复声明</li>
                <li><strong>不绑定全局对象</strong>：全局 let 不会成为 window 的属性</li>
            </ul>
            
            <h3>2.2 暂时性死区（Temporal Dead Zone）</h3>
            <p>从块的开始到变量声明之前的区域被称为暂时性死区。在这个区域内访问变量会抛出 ReferenceError。</p>
            
            <div class="spec">
                ECMAScript 规范规定：let 和 const 声明的变量会创建绑定，但在执行到声明语句之前，这些绑定处于"未初始化"状态。
            </div>
            
            <h3>2.3 块级作用域的优势</h3>
            <p>块级作用域解决了 var 的许多问题，特别是在循环和条件语句中。</p>
            
            <h2>三、const 声明（ES6）</h2>
            
            <h3>3.1 基本特性</h3>
            <ul>
                <li>具有 let 的所有特性（块级作用域、TDZ等）</li>
                <li><strong>必须初始化</strong>：声明时必须赋值</li>
                <li><strong>不可重新赋值</strong>：绑定是不可变的</li>
                <li><strong>对象属性可变</strong>：const 只保证引用不变，对象内容可变</li>
            </ul>
            
            <div class="warning">
                const 的"常量"是指变量标识符与值的绑定关系不可变，而不是值本身不可变！
            </div>
            
            <h3>3.2 对象冻结</h3>
            <p>如果需要真正的不可变对象，需要使用 <code>Object.freeze()</code>：</p>
            
            <h2>四、对比总结</h2>
            
            <table>
                <thead>
                    <tr>
                        <th>特性</th>
                        <th>var</th>
                        <th>let</th>
                        <th>const</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>作用域</td>
                        <td>函数作用域</td>
                        <td>块级作用域</td>
                        <td>块级作用域</td>
                    </tr>
                    <tr>
                        <td>变量提升</td>
                        <td>是（undefined）</td>
                        <td>是（TDZ）</td>
                        <td>是（TDZ）</td>
                    </tr>
                    <tr>
                        <td>重复声明</td>
                        <td>允许</td>
                        <td>不允许</td>
                        <td>不允许</td>
                    </tr>
                    <tr>
                        <td>重新赋值</td>
                        <td>允许</td>
                        <td>允许</td>
                        <td>不允许</td>
                    </tr>
                    <tr>
                        <td>全局对象属性</td>
                        <td>是</td>
                        <td>否</td>
                        <td>否</td>
                    </tr>
                    <tr>
                        <td>初始化要求</td>
                        <td>可选</td>
                        <td>可选</td>
                        <td>必须</td>
                    </tr>
                </tbody>
            </table>
            
            <h2>五、最佳实践</h2>
            
            <div class="tip">
                <strong>推荐使用顺序：</strong>
                <ol>
                    <li>优先使用 <code>const</code>：声明不会重新赋值的变量</li>
                    <li>其次使用 <code>let</code>：需要重新赋值的变量</li>
                    <li>避免使用 <code>var</code>：除非有特殊需求（如兼容性）</li>
                </ol>
            </div>
            
            <h2>参考资料</h2>
            <ul>
                <li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/var" target="_blank">MDN - var</a></li>
                <li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/let" target="_blank">MDN - let</a></li>
                <li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/const" target="_blank">MDN - const</a></li>
                <li><a href="https://tc39.es/ecma262/#sec-let-and-const-declarations" target="_blank">ECMAScript - Let and Const Declarations</a></li>
            </ul>
            
            <div class="nav-links">
                <a href="01-intro.html" class="nav-link prev">上一节：JavaScript 简介</a>
                <a href="../index.html" class="nav-link home">返回首页</a>
                <a href="01-datatypes.html" class="nav-link next">下一节：数据类型详解</a>
                <a href="../interview/basics/01-variables.html" class="nav-link" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">📝 本章面试题</a>
            </div>
        </div>
        
        <!-- 代码面板 -->
        <div class="code-panel">
            <h2 style="color: #60a5fa; margin-bottom: 1.5rem;">💻 交互式代码示例</h2>
            
            <!-- 示例1: var 提升 -->
            <div class="code-example">
                <h3>示例 1：var 的变量提升</h3>
                <div class="code-block">
                    <pre><code>console.log('x 的值:', x);  // undefined（提升但未赋值）
var x = 10;
console.log('赋值后 x:', x);  // 10

// 相当于：
// var x;
// console.log('x 的值:', x);
// x = 10;</code></pre>
                </div>
                <button class="run-btn">▶ 运行代码</button>
                <div class="output"></div>
            </div>
            
            <!-- 示例2: let 的 TDZ -->
            <div class="code-example">
                <h3>示例 2：let 的暂时性死区</h3>
                <div class="code-block">
                    <pre><code>try {
    console.log('y 的值:', y);  // ReferenceError!
    let y = 20;
} catch (e) {
    console.error('捕获错误:', e.message);
}

// 正确使用
let z = 30;
console.log('z 的值:', z);  // 30</code></pre>
                </div>
                <button class="run-btn">▶ 运行代码</button>
                <div class="output"></div>
            </div>
            
            <!-- 示例3: 块级作用域 -->
            <div class="code-example">
                <h3>示例 3：块级作用域对比</h3>
                <div class="code-block">
                    <pre><code>// var 没有块级作用域
if (true) {
    var a = 100;
}
console.log('块外访问 var a:', a);  // 100 (可以访问)

// let 有块级作用域
if (true) {
    let b = 200;
    console.log('块内访问 let b:', b);  // 200
}
try {
    console.log('块外访问 let b:', b);  // ReferenceError
} catch (e) {
    console.error('无法访问:', e.message);
}</code></pre>
                </div>
                <button class="run-btn">▶ 运行代码</button>
                <div class="output"></div>
            </div>
            
            <!-- 示例4: 循环中的经典问题 -->
            <div class="code-example">
                <h3>示例 4：循环中的 var vs let</h3>
                <div class="code-block">
                    <pre><code>// var 的问题
var funcs1 = [];
for (var i = 0; i < 3; i++) {
    funcs1.push(function() {
        return i;
    });
}
console.log('var 循环结果:', funcs1[0](), funcs1[1](), funcs1[2]());  // 3, 3, 3

// let 的解决方案
var funcs2 = [];
for (let j = 0; j < 3; j++) {
    funcs2.push(function() {
        return j;
    });
}
console.log('let 循环结果:', funcs2[0](), funcs2[1](), funcs2[2]());  // 0, 1, 2</code></pre>
                </div>
                <button class="run-btn">▶ 运行代码</button>
                <div class="output"></div>
            </div>
            
            <!-- 示例5: const 的特性 -->
            <div class="code-example">
                <h3>示例 5：const 的不可变性</h3>
                <div class="code-block">
                    <pre><code>// const 不可重新赋值
const PI = 3.14159;
console.log('PI:', PI);

try {
    PI = 3.14;  // TypeError!
} catch (e) {
    console.error('不能重新赋值:', e.message);
}

// 但对象属性可以修改
const obj = { name: 'Alice', age: 25 };
console.log('原始对象:', obj);

obj.age = 26;  // 可以修改属性
console.log('修改后:', obj);

// Object.freeze 冻结对象
const frozen = Object.freeze({ x: 1 });
frozen.x = 2;  // 静默失败（严格模式下报错）
console.log('冻结对象:', frozen);  // { x: 1 }</code></pre>
                </div>
                <button class="run-btn">▶ 运行代码</button>
                <div class="output"></div>
            </div>
        </div>
    </div>
    
    <script src="../assets/js/common.js"></script>
</body>
</html>
