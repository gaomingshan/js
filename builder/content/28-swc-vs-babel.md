# SWC 与 Babel 的定位差异

## 概述

Babel 与 SWC 都属于“源码转换（transform）”这一层：把 TS/JSX/新语法转换为目标 JS。

它们最大的差异不是“能不能转”，而是：

- Babel：**生态与可扩展性优先**（插件丰富、兼容历史强）
- SWC：**性能优先**（Rust 实现，速度快，覆盖主流 transform）

> **关键点**
>
> 真实工程里它们经常不是二选一：Babel 负责“复杂/定制化转换”，SWC 负责“常规高速转换”。

---

## 一、共同点：它们都在做 AST 变换

你可以把它们都理解为：

```text
源码
  ↓ parse
AST
  ↓ transform（插件/规则）
AST
  ↓ print
目标 JS
```

因此它们都能完成：

- TS/JSX 转译（类型擦除、JSX 变换）
- 新语法降级（按目标环境）
- 一些编译期替换（例如宏/常量折叠）

---

## 二、Babel：为什么它仍然不可替代

### 2.1 插件生态极强

Babel 的最大价值是“可编程的转换平台”：

- 历史包袱与实验特性支持多
- 自定义插件成熟（团队定制）
- 社区工具链往往默认支持 Babel

### 2.2 适合“非标准/复杂转换”

例如：

- 依赖某些特定 Babel 插件的业务代码
- 需要实现自定义编译期语义（宏、代码注入、语法扩展）

> **直觉理解**
>
> Babel 的优势不是“快”，而是“你能用它做到非常多别人做不到的转换”。

---

## 三、SWC：它的价值主要来自性能

### 3.1 为什么会快

- Rust 实现
- 更强调工程路径的性能与并行

在大型项目或频繁 rebuild 的场景下，SWC 的速度优势更明显。

### 3.2 适合“常规转换”与“工程加速”

- 替换 Babel 做 TS/JSX 转译
- 提升 dev/CI 速度
- 被框架与工具集成（常见于现代框架生态）

> **关键点**
>
> SWC 在“覆盖面”上通常足够，但在“特殊插件需求/兼容细节”上需要评估。

---

## 四、常见误区：转译器 ≠ 类型检查器

无论 Babel 还是 SWC：

- 都可以“把 TS 转成 JS”
- 但都不等价于 `tsc` 的类型检查

因此真实工程常见做法是：

- Dev：用 SWC/esbuild 做快速转译
- CI：再跑 `tsc --noEmit` 做类型检查

---

## 五、怎么选（可执行）

### 5.1 优先选 Babel，如果

- 你依赖大量 Babel 插件（或需要自定义插件）
- 你项目里存在较多非标准/历史转换需求
- 你更看重生态兼容与可控性

### 5.2 优先选 SWC，如果

- 你的转换需求主要是 TS/JSX/常规语法降级
- 你更看重构建速度与开发反馈
- 你希望在大型项目里显著降低 CI/本地构建耗时

### 5.3 组合使用（很常见）

- 默认用 SWC 提速
- 对少数特殊文件/特性保留 Babel（作为补丁层）

---

## 参考资料

- [Babel](https://babeljs.io/)
- [SWC](https://swc.rs/)
- [TypeScript - Compiler Options](https://www.typescriptlang.org/docs/handbook/compiler-options.html)
