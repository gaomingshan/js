window.quizData_Basics03ErrorHandling = {
  "config": {
    "title": "错误处理",
    "icon": "⚠️",
    "description": "try-catch与错误类型",
    "primaryColor": "#667eea",
    "bgGradient": "linear-gradient(135deg, #667eea 0%, #764ba2 100%)"
  },
  "questions": [
    {"difficulty": "easy", "tags": ["try-catch"], "question": "如何捕获JavaScript错误？", "options": ["try { } catch (e) { }", "catch { }", "error { }", "trap { }"], "correctAnswer": "A", "explanation": {"title": "try-catch语法", "sections": [{"title": "基本用法", "code": "try {\n  // 可能出错的代码\n  JSON.parse('invalid');\n} catch (error) {\n  console.log(error.message);\n} finally {\n  // 总是执行\n}"}]}, "source": "错误处理"},
    {"difficulty": "easy", "type": "true-false", "tags": ["finally"], "question": "finally块总是会执行，即使try中有return。", "options": ["正确", "错误"], "correctAnswer": "A", "explanation": {"title": "finally特性", "content": "正确！finally总是执行。", "sections": [{"title": "示例", "code": "function test() {\n  try {\n    return 'try';\n  } finally {\n    console.log('执行了');  // 总是执行\n  }\n}"}]}, "source": "finally"},
    {"difficulty": "medium", "type": "multiple", "tags": ["错误类型"], "question": "JavaScript内置的错误类型有哪些？", "options": ["Error", "TypeError", "ReferenceError", "SyntaxError"], "correctAnswer": ["A", "B", "C", "D"], "explanation": {"title": "错误类型", "content": "所有选项都是内置错误类型！", "sections": [{"title": "常见错误", "code": "// TypeError\n''.foo();  // 类型错误\n\n// ReferenceError\nconsole.log(x);  // 未定义\n\n// SyntaxError\neval('{');  // 语法错误"}]}, "source": "错误类型"},
    {"difficulty": "medium", "type": "code-output", "tags": ["错误捕获"], "question": "以下代码的输出是什么？", "code": "try {\n  console.log('A');\n  throw new Error('错误');\n  console.log('B');\n} catch (e) {\n  console.log('C');\n}", "options": ["A, C", "A, B", "C", "A, B, C"], "correctAnswer": "A", "explanation": {"title": "throw中断执行", "sections": [{"title": "分析", "code": "try {\n  console.log('A');  // 输出A\n  throw new Error('错误');  // 抛出错误，中断执行\n  console.log('B');  // 不执行\n} catch (e) {\n  console.log('C');  // 输出C\n}\n// 输出：A C"}]}, "source": "throw"},
    {"difficulty": "medium", "type": "code-completion", "tags": ["自定义错误"], "question": "如何抛出一个错误？", "code": "if (!user) {\n  ______ new Error('用户不存在');\n}", "options": ["throw", "raise", "error", "catch"], "correctAnswer": "A", "explanation": {"title": "throw语句", "sections": [{"title": "用法", "code": "// 抛出Error对象\nthrow new Error('错误信息');\n\n// 抛出自定义错误\nthrow new TypeError('类型错误');\n\n// 可以抛出任何值\nthrow 'string';\nthrow 42;\nthrow { message: 'error' };"}]}, "source": "throw"},
    {"difficulty": "medium", "type": "multiple", "tags": ["错误处理最佳实践"], "question": "错误处理的最佳实践包括？", "options": ["捕获具体错误类型", "提供有意义的错误信息", "使用finally清理资源", "不要空catch块"], "correctAnswer": ["A", "B", "C", "D"], "explanation": {"title": "最佳实践", "content": "所有选项都正确！", "sections": [{"title": "示例", "code": "try {\n  const data = JSON.parse(str);\n} catch (error) {\n  if (error instanceof SyntaxError) {\n    console.error('JSON格式错误:', error.message);\n  } else {\n    throw error;  // 重新抛出未知错误\n  }\n} finally {\n  cleanup();  // 清理资源\n}"}]}, "source": "最佳实践"},
    {"difficulty": "hard", "type": "code-output", "tags": ["异步错误"], "question": "try-catch能捕获以下哪个错误？", "code": "try {\n  setTimeout(() => {\n    throw new Error('异步错误');\n  }, 0);\n} catch (e) {\n  console.log('捕获到');\n}", "options": ["不能捕获，程序崩溃", "能捕获", "输出'捕获到'", "不报错"], "correctAnswer": "A", "explanation": {"title": "异步错误捕获", "sections": [{"title": "分析", "code": "// try-catch无法捕获异步错误\ntry {\n  setTimeout(() => {\n    throw new Error('异步错误');\n  }, 0);\n} catch (e) {\n  // 捕获不到\n}\n\n// 正确做法：\nsetTimeout(() => {\n  try {\n    throw new Error('异步错误');\n  } catch (e) {\n    console.log('捕获到');\n  }\n}, 0);"}]}, "source": "异步错误"},
    {"difficulty": "hard", "type": "multiple", "tags": ["Promise错误"], "question": "如何捕获Promise错误？", "options": [".catch()", "try-catch with async/await", "全局unhandledrejection事件", "都可以"], "correctAnswer": ["D"], "explanation": {"title": "Promise错误处理", "content": "选项D正确！都可以捕获。", "sections": [{"title": "三种方式", "code": "// 方式1：.catch()\npromise.catch(err => console.error(err));\n\n// 方式2：async/await\nasync function test() {\n  try {\n    await promise;\n  } catch (err) {\n    console.error(err);\n  }\n}\n\n// 方式3：全局事件\nwindow.addEventListener('unhandledrejection', e => {\n  console.error(e.reason);\n});"}]}, "source": "Promise错误"},
    {"difficulty": "hard", "type": "code-completion", "tags": ["自定义错误类"], "question": "如何创建自定义错误类？", "code": "class CustomError ______ Error {\n  constructor(message) {\n    super(message);\n    this.name = 'CustomError';\n  }\n}", "options": ["extends", "implements", "inherits", "from"], "correctAnswer": "A", "explanation": {"title": "自定义错误类", "sections": [{"title": "完整示例", "code": "class ValidationError extends Error {\n  constructor(message) {\n    super(message);\n    this.name = 'ValidationError';\n  }\n}\n\n// 使用\ntry {\n  throw new ValidationError('验证失败');\n} catch (error) {\n  if (error instanceof ValidationError) {\n    console.log('验证错误:', error.message);\n  }\n}"}]}, "source": "自定义错误"},
    {"difficulty": "hard", "type": "code-output", "tags": ["finally return"], "question": "以下代码的返回值是什么？", "code": "function test() {\n  try {\n    return 'try';\n  } finally {\n    return 'finally';\n  }\n}\nconsole.log(test());", "options": ["'finally'", "'try'", "undefined", "Error"], "correctAnswer": "A", "explanation": {"title": "finally的return覆盖", "sections": [{"title": "分析", "code": "function test() {\n  try {\n    return 'try';  // 被覆盖\n  } finally {\n    return 'finally';  // 最终返回这个\n  }\n}\ntest();  // 'finally'\n\n// 注意：不推荐在finally中return\n// 会覆盖try中的return"}]}, "source": "finally"}
  ],
  "navigation": {
    "prev": {"title": "循环语句", "url": "03-loops.html"},
    "next": {"title": "函数基础", "url": "04-function-basics.html"}
  }
};
