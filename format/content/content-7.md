# 规范制定与渐进式导入

## 概述

团队规范不是技术负责人的"一言堂"，而是需要团队共识、渐进式导入、持续演进的系统工程。

**核心认知**：
- 规范制定需要团队共识，避免强制推行导致反弹
- 新项目严格执行，历史项目渐进式改造
- 规范需要演进，定期回顾与调整

**后端类比**：
- 规范制定 ≈ 技术方案评审
- 渐进式导入 ≈ 灰度发布
- 规范演进 ≈ 技术栈升级策略

---

## 规范制定原则

### 团队共识建立

**错误做法**：
```
技术负责人制定规范
  ↓
直接强制执行
  ↓
团队抵触
  ↓
规范形同虚设
```

**正确做法**：
```
1. 提出规范草案
2. 团队讨论（收集意见）
3. 争议点投票
4. 试运行 1-2 周
5. 收集反馈
6. 正式执行
```

**案例：单引号 vs 双引号**

**场景**：
```
开发者 A: "应该用单引号，更简洁"
开发者 B: "双引号更清晰"
开发者 C: "我觉得无所谓"
```

**解决策略**：
1. **优先**：交给工具（Prettier 默认）
2. **次选**：参考行业标准（Airbnb、Google）
3. **最后**：投票表决（少数服从多数）

**核心理念**：
> 统一比正确更重要，共识比完美更重要。

---

### 自上而下 vs 自下而上

**自上而下**：
```
技术负责人制定 → 团队执行
```

**优势**：
- 决策快
- 执行力强

**劣势**：
- 可能脱离实际
- 团队抵触

**适用场景**：新项目、紧急情况

---

**自下而上**：
```
团队讨论 → 达成共识 → 执行
```

**优势**：
- 团队认同度高
- 执行阻力小

**劣势**：
- 决策慢
- 可能陷入争论

**适用场景**：成熟团队、历史项目

---

**混合模式**（推荐）：
```
技术负责人提出草案（自上而下）
  ↓
团队讨论调整（自下而上）
  ↓
达成共识后执行
```

**后端类比**：敏捷开发中的 Sprint Planning。

---

## 渐进式导入策略

### 新项目 vs 历史项目

**新项目（严格执行）**：
```json
{
  "extends": ["airbnb", "prettier"],
  "rules": {
    "no-unused-vars": "error",
    "eqeqeq": "error",
    "complexity": ["error", 10]
  }
}
```

**优势**：
- 技术债从源头控制
- 无历史包袱
- 建立高质量基线

---

**历史项目（渐进式改造）**：

**第一阶段（止血）**：
```json
{
  "rules": {
    "no-undef": "error",      // 严重问题
    "no-unused-vars": "warn"  // 其他问题先警告
  }
}
```

**第二阶段（3 个月后）**：
```json
{
  "rules": {
    "no-undef": "error",
    "no-unused-vars": "error",  // 升级为错误
    "eqeqeq": "warn"
  }
}
```

**第三阶段（6 个月后）**：
```json
{
  "extends": ["airbnb", "prettier"],
  "rules": {
    // 全部规则生效
  }
}
```

**原则**：
- 避免一次性引入大量错误
- 降低团队阻力
- 平滑过渡

**后端类比**：数据库 schema 的渐进式迁移。

---

### 规则的分级与优先级

**P0：严重问题**（必须修复）
```json
{
  "rules": {
    "no-undef": "error",
    "no-unused-vars": "error"
  }
}
```

**P1：质量问题**（建议修复）
```json
{
  "rules": {
    "eqeqeq": "warn",
    "no-var": "warn"
  }
}
```

**P2：风格问题**（可选）
```json
{
  "rules": {
    "quotes": "off",  // 交给 Prettier
    "semi": "off"
  }
}
```

**改造计划**：
```
Week 1-2: 修复 P0 问题
Week 3-4: 修复 P1 问题
Week 5-6: 统一 P2 风格
```

---

### 避免"一刀切"导致的反弹

**错误做法**：
```
引入 ESLint
  ↓
10 万行代码报 5000 个错误
  ↓
要求 1 周内全部修复
  ↓
团队压力大
  ↓
规范被放弃
```

**正确做法**：
```
1. 评估影响范围
2. 制定分阶段计划
3. 自动修复优先
4. 人工修复分批进行
5. 定期回顾进度
```

**工具支持**：
```bash
# 自动修复
eslint --fix src/**/*.js

# 查看剩余问题
eslint src/**/*.js | tee lint-report.txt

# 分析错误类型
cat lint-report.txt | grep "error" | sort | uniq -c
```

---

## 规范文档化与培训

### 规范文档的编写要点

**文档结构**：
```markdown
# 前端代码规范

## 1. 概述
- 规范的目标
- 适用范围

## 2. 工具链
- ESLint 配置
- Prettier 配置
- Git Hooks 使用

## 3. 规则说明
- 核心规则解释
- 常见问题 FAQ

## 4. 示例代码
- ✅ 正确示例
- ❌ 错误示例

## 5. 例外场景
- 何时可以禁用规则
- 如何申请例外
```

**编写原则**：
- 简洁明了
- 示例丰富
- 易于查找

**后端类比**：API 文档的编写规范。

---

### Code Review 中的规范教育

**错误做法**：
```
Reviewer: "这里违反了规范，重新提交"
→ 开发者不知道为什么
→ 重复犯错
```

**正确做法**：
```
Reviewer: "这里违反了 no-var 规则，原因是：
1. var 是函数作用域，容易产生全局污染
2. 推荐使用 let/const
3. 参考：[规范文档链接]"
→ 开发者理解原因
→ 避免重复犯错
```

**Review 模板**：
```markdown
## 规范问题

**问题**：使用了 var 声明变量

**规则**：no-var

**原因**：
- var 是函数作用域，容易产生全局污染
- let/const 是块级作用域，更安全

**修改建议**：
\`\`\`javascript
// ❌ 错误
var count = 0;

// ✅ 正确
const count = 0;  // 不会重新赋值
let index = 0;    // 会重新赋值
\`\`\`

**参考**：[团队规范文档 - 变量声明]
```

---

### 自动化工具的培训与推广

**培训内容**：
1. VSCode 插件安装
2. 编辑器配置
3. Git Hooks 使用
4. 常见问题排查

**培训形式**：
- 新人入职培训
- 团队分享会
- 规范文档 + 视频教程

**推广策略**：
- 降低使用门槛（一键配置）
- 提供模板项目
- 及时响应问题

---

## 规范演进机制

### 更新时机与频率

**定期回顾**：
```
每季度：规范回顾会
  ↓
收集团队反馈
  ↓
评估规则合理性
  ↓
调整不合理规则
  ↓
更新规范文档
```

**触发更新的场景**：
1. 技术栈升级（React 16 → 18）
2. 团队规模变化（3 人 → 10 人）
3. 规则执行困难（80% 违规率）
4. 工具升级（ESLint 7 → 8）

---

### 破坏性变更的处理

**场景**：ESLint 8 引入新规则，导致大量错误

**处理策略**：

**1. 评估影响范围**
```bash
# 升级前检查
npm install eslint@8 --save-dev
npm run lint 2>&1 | tee upgrade-report.txt

# 统计错误数量
grep "error" upgrade-report.txt | wc -l
```

**2. 制定迁移计划**
```
Week 1: 自动修复（eslint --fix）
Week 2-4: 人工修复剩余问题
Week 5: 全部修复完成
```

**3. 通知团队**
```markdown
## 规范升级通知

**升级内容**：ESLint 7 → 8

**影响范围**：
- 新增 50 个错误
- 主要是 React Hooks 规则

**时间安排**：
- Week 1: 自动修复
- Week 2-4: 人工修复
- Week 5: 全部完成

**需要团队配合**：
- 及时更新本地依赖
- 修复 lint 错误后再提交

**常见问题**：[FAQ 文档]
```

**后端类比**：数据库 schema 迁移通知。

---

### 规范的持续优化

**优化流程**：
```
1. 收集反馈
   - 团队成员反馈
   - Code Review 中的问题
   - 规范执行数据

2. 分析问题
   - 哪些规则执行困难
   - 哪些规则经常被禁用
   - 哪些规则违规率高

3. 调整规则
   - 降低不合理规则的级别（error → warn）
   - 移除无效规则
   - 新增必要规则

4. 通知团队
   - 规范变更说明
   - 影响评估
   - 迁移指南
```

**数据驱动优化**：
```bash
# 统计规则违规率
eslint src/**/*.js --format json | \
  jq '.[] | .messages[] | .ruleId' | \
  sort | uniq -c | sort -rn

# 示例输出
# 150 no-console
#  80 no-unused-vars
#  50 complexity
```

**分析**：
- `no-console` 违规率高 → 是否需要调整？
- `complexity` 违规多 → 是否阈值太严格？

---

## 深入一点：规范推广的心理学

### 降低团队阻力

**阻力来源**：
1. 习惯改变的不适
2. 学习成本
3. 短期效率下降

**应对策略**：

**1. 强调价值**
```
不是："必须遵守规范"
而是："规范能帮助我们：
- 减少 Code Review 时间 40%
- 降低 Bug 率 30%
- 提升新人上手速度"
```

**2. 降低成本**
```
- 提供自动化工具（保存即格式化）
- 提供模板项目（一键启动）
- 提供详细文档（快速查询）
```

**3. 渐进式推进**
```
- 先易后难
- 先自动化，后人工
- 先新项目，后历史项目
```

---

### 建立正反馈循环

```
执行规范
  ↓
代码质量提升
  ↓
Code Review 时间减少
  ↓
开发效率提升
  ↓
团队认可规范
  ↓
更愿意执行规范
```

**关键点**：及时展示规范的价值。

**数据展示**：
```markdown
## 规范执行效果

**实施前**（3 个月前）：
- Code Review 平均时间：30 分钟
- Bug 率：15%
- 新人上手时间：2 周

**实施后**（现在）：
- Code Review 平均时间：10 分钟（-67%）
- Bug 率：10%（-33%）
- 新人上手时间：3 天（-75%）
```

---

## 参考资料

- [Airbnb JavaScript Style Guide](https://github.com/airbnb/javascript)
- [Google JavaScript Style Guide](https://google.github.io/styleguide/jsguide.html)
- [Clean Code](https://www.amazon.com/Clean-Code-Handbook-Software-Craftsmanship/dp/0132350882)
